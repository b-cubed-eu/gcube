---
title: "1. Simulating the occurrence process"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{occurrence-process}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The workflow for simulating a biodiversity data cube used in gcube can be divided in three steps or processes:

1. Occurrence process
2. Detection process
3. Grid designation process

This vignette documents the first part of the gcube simulation workflow, viz. the occurrence process.

```{r setup, warning=FALSE, message=FALSE}
# Load packages
library(gcube)

library(sf)        # work with spatial objects
library(tidyverse) # data wrangling and visualisation
library(tidyterra) # visualisation spatraster objects
```

# Input

The functions are set up such that a single polygon as input is enough to go through this workflow using default arguments.
The user can change these arguments to allow for more flexibility.
In this vignette we will demonstrate the different options.

As input, we create a polygon in which we want to simulate occurrences.

```{r}
polygon <- st_polygon(list(cbind(c(500, 1000, 1000, 600, 200, 100, 500),
                                 c(200, 100, 700, 1000, 900, 500, 200))))
```

The polygon looks like this.

```{r}
ggplot() +
  geom_sf(data = polygon) +
  theme_minimal()
```

# Simulate occurrences

We generate occurrence points within the polygon using the `simulate_occurrences()` function.
Default arguments ensure that an sf object with POLYGON geometry is sufficient to simulate occurrences.

```
?simulate_occurrences
```

The options for user defined arguments are demonstrated in the next subsections.

## Changing number of occurrences over time

Say we want to have 100 occurrences in our plot over 10 years.
You can change the trend in number of occurrences over time.
We visualise this with the helper functions used in `simulate_occurrences()`.
The number of occurrences are always drawn from a Poisson distribution.

```
?simulate_timeseries
```

**Option 1**

If we do not specify a temporal function, we draw from a Poisson distribution for each time point with average (lambda parameter) `initial_average_occurrences`.

```{r}
n_occurrences_indep <- simulate_timeseries(
  initial_average_occurrences = 100,
  n_time_points = 10,
  temporal_function = NA,
  seed = 123)
```

We plot the simulated number of occurrences over time.
We see that the average is close to 100 over time as expected.
Using a different seed will result in different numbers but the average will be (close to) 100 over time.

```{r}
tibble(
  n_occurrences = n_occurrences_indep,
  time_point = seq_along(n_occurrences_indep)
  ) %>%
  ggplot(aes(x = time_point, y = n_occurrences)) +
    geom_point() +
    geom_smooth(method = "lm", formula = "y ~ x", se = FALSE) +
    theme_minimal()
```

**Option 2**

We can specify a function ourselves, e.g. the internal function `simulate_random_walk()` to have a random walk over time.
A random walk is a mathematical concept where each step is determined randomly.
The `sd_step` parameter refers to the standard deviation of these random steps (drawn from a Normal distribution).
A higher value leading to larger steps and potentially greater variability in the path of the random walk.

```{r}
n_occurrences_walk <- simulate_timeseries(
  initial_average_occurrences = 100,
  n_time_points = 10,
  temporal_function = simulate_random_walk,
  sd_step = 1,
  seed = 123)
```

We plot the simulated number of occurrences over time which follow a random walk.
Using a different seed will result in a different random pattern.

```{r}
tibble(
  n_occurrences = n_occurrences_walk,
  time_point = seq_along(n_occurrences_walk)
  ) %>%
  ggplot(aes(x = time_point, y = n_occurrences)) +
    geom_point() +
    theme_minimal()
```

**Option 3**

We can specify a function ourselves that determines the average trend in number of occurrences over time.
Here we provide an example for a linear trend.

```{r}
my_own_linear_function <- function(
    initial_average_occurrences = initial_average_occurrences,
    n_time_points = n_time_points,
    coef) {
  # Calculate new average abundances over time
  time <- seq_len(n_time_points) - 1
  lambdas <- initial_average_occurrences + (coef * time)

  # Identify where the lambda values become 0 or lower
  zero_or_lower_index <- which(lambdas <= 0)

  # If any lambda becomes 0 or lower, set all subsequent lambdas to 0
  if (length(zero_or_lower_index) > 0) {
    zero_or_lower_indices <- zero_or_lower_index[1]:n_time_points
    lambdas[zero_or_lower_indices] <- 0
  }

  # Return average abundances
  return(lambdas)
}
```

We try out a linear trend with slope equal to 1.

```{r}
n_occurrences_linear <- simulate_timeseries(
  initial_average_occurrences = 100,
  n_time_points = 10,
  temporal_function = my_own_linear_function,
  coef = 1,
  seed = 123)
```

We plot the simulated number of occurrences over time.
We see that the average slope is indeed close to 1.
Using a different seed will result in different numbers but the average slope will be (close to) 1.

```{r}
tibble(
  n_occurrences = n_occurrences_linear,
  time_point = seq_along(n_occurrences_linear)
  ) %>%
  ggplot(aes(x = time_point, y = n_occurrences)) +
  geom_point() +
  geom_smooth(method = "lm", formula = "y ~ x", se = FALSE) +
  theme_minimal()
```

## Changing the degree of spatial clustering






# Examples
