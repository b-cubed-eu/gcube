---
title: "Grid designation for custom datasets"
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This tutorial provides a theoretical explanation of grid designation is performed and how **gcube** can be used to for uniform grid designation on any ecological dataset (not only simulated datasets). The method differs between projected (planar) and geographic (degree-based) coordinate reference systems (CRS).

## Method

To generate a point within a circle of radius $r$ around a central coordinate $(x_0, y_0)$, we use polar coordinates and convert to Cartesian coordinates.

1. Sample a **random angle** from the uniform distribution $\mathcal{U}$:
   
$$
\theta \sim \mathcal{U}(0, 2\pi)
$$

2. Sample a **random radius** scaled by square root to ensure uniform point density:

$$
r' = \sqrt{\mathcal{U}(0, 1)} \cdot r
$$

3. Convert to Cartesian coordinates:

$$
x = x_0 + r' \cos(\theta)
$$

$$
y = y_0 + r' \sin(\theta)
$$

## Coordinate Reference System Considerations

The method of applying the above formula depends on the unit system of your CRS.

### Projected CRS (e.g., UTM)

Projected systems use **meters** or other linear units, so the polar formula can be applied directly.

| Quantity | Formula |
|----------|---------|
| $x$ offset | $x = x_0 + r \cos(\theta)$ |
| $y$ offset | $y = y_0 + r \sin(\theta)$ |

This is the most accurate and straightforward method and should be used whenever your data are in a projected CRS.

### Geographic CRS (e.g., WGS84)

Geographic systems use **degrees**, not meters. Therefore, the uncertainty radius in meters must be converted to degrees using approximations based on latitude:

- 1 degree of latitude ≈ 111,320 meters
- 1 degree of longitude ≈ $111{,}320 \cdot \cos(\text{latitude})$ meters

Use these formulas to convert meters to degrees:

| Quantity | Formula |
|----------|---------|
| Latitude offset | $\Delta \text{lat} = \dfrac{r \sin(\theta)}{111320}$ |
| Longitude offset | $\Delta \text{lon} = \dfrac{r \cos(\theta)}{111320 \cdot \cos(\text{lat})}$ |

These are **approximations** and may introduce distortion, especially at high latitudes.

## Getting started with gcube

In this example, we show how **gcube** can be used to perform grid designation on a custom ecological dataset.

```{r, message=FALSE, warning=FALSE}
# Load packages
library(gcube)


library(frictionless) # Load example dataset
library(ggplot2)      # Data visualisation
library(dplyr)        # Data wrangling
library(sf)           # Working with spatial data
```

### Get example data

As reference grid, we load the the MGRS grid at 10 km scale from the **b3data** data package.

```{r}
# Read data from repository
mgrs10_belgium <- st_read(
  "https://zenodo.org/records/15211029/files/mgrs10_refgrid_belgium.gpkg",
  quiet = TRUE
)
head(mgrs10_belgium)
```

Consider the following synthetic observation dataset with three species observed across three different years. Each row represents a record with spatial coordinates and an associated uncertainty in meters.

```{r}
# Simulate 9 observation records: 3 species x 3 years
example_data <- data.frame(
  species = rep(c("species1", "species2", "species3"), each = 3),
  time_point = rep(2020:2022, times = 3),
  lat = runif(9, st_bbox(mgrs10_belgium)$ymin, st_bbox(mgrs10_belgium)$ymax),
  long = runif(9, st_bbox(mgrs10_belgium)$xmin, st_bbox(mgrs10_belgium)$xmax),
  coordinateUncertaintyInMeters = c(100, 250, 500, 150, 100, 300, 400, 250, 350)
) %>%
  st_as_sf(coords = c("long", "lat"), crs = st_crs(mgrs10_belgium))
example_data
```
