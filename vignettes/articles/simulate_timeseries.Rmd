---
title: "simulate_timeseries"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(simcuber)
library(ggplot2)
```
## 1. Use the function simulate_random_walk()
```{r}
simulate_timeseries(
  initial_average_occurrences = 50,
  n_time_points = 10,
  temporal_function = simulate_random_walk,
  sd_step = 1,
  seed = 123
)
```

#>  [1] 46 52 66 54 52 43 56 38 46 43

## 2. Visualising multiple draws
# Set seed for reproducibility
```{r}
set.seed(123)
```


# Draw n_sim abundances from Poisson distribution using random walk
```{r}
n_sim <- 10
n_time_points <- 50
sd_step <- 1
list_abundances <- vector("list", length = n_sim)

```


# Loop n_sim times over simulate_timeseries()
```{r}
for (i in seq_len(n_sim)) {
  abundances <- simulate_timeseries(
    initial_average_occurrences = 50,
    n_time_points = n_time_points,
    temporal_function = simulate_random_walk,
    sd_step = sd_step
  )

  list_abundances[[i]] <- data.frame(
    time = seq_along(abundances),
    abundance = abundances,
    sim = i
  )
}
```


# Combine list of dataframes
```{r}
data_abundances <- do.call(rbind.data.frame, list_abundances)

```

# Plot the simulated abundances over time using ggplot2
```{r}
ggplot(data_abundances, aes(x = time, y = abundance, colour = factor(sim))) +
  geom_line() +
  labs(
    x = "Time", y = "Species abundance",
    title = paste(
      n_sim, "simulated abundances using random walk",
      "with sd =", sd_step
    )
  ) +
  scale_y_continuous(limits = c(0, NA)) +
  scale_x_continuous(breaks = seq(0, n_time_points, 5)) +
  theme_minimal() +
  theme(legend.position = "")
```



## 3. Using your own function
# You can also specify your own trend function, e.g. this linear function
```{r}
my_own_linear_function <- function(
    initial_average_occurrences = initial_average_occurrences,
    n_time_points = n_time_points,
    coef) {
  # Calculate new average abundances over time
  time <- seq_len(n_time_points) - 1
  lambdas <- initial_average_occurrences + (coef * time)

  # Identify where the lambda values become 0 or lower
  zero_or_lower_index <- which(lambdas <= 0)

  # If any lambda becomes 0 or lower, set all subsequent lambdas to 0
  if (length(zero_or_lower_index) > 0) {
    zero_or_lower_indices <- zero_or_lower_index[1]:n_time_points
    lambdas[zero_or_lower_indices] <- 0
  }

  # Return average abundances
  return(lambdas)
}

```

# Set seed for reproducibility
```{r}
set.seed(123)
```


# Draw n_sim abundances from Poisson distribution using our own function
```{r}
n_sim <- 10
n_time_points <- 50
slope <- 1
list_abundances <- vector("list", length = n_sim)

```

# Loop n_sim times over simulate_timeseries()
```{r}
for (i in seq_len(n_sim)) {
  abundances <- simulate_timeseries(
    initial_average_occurrences = 50,
    n_time_points = n_time_points,
    temporal_function = my_own_linear_function,
    coef = slope
  )

  list_abundances[[i]] <- data.frame(
    time = seq_along(abundances),
    abundance = abundances,
    sim = i
  )
}
```


# Combine list of dataframes
```{r}
data_abundances <- do.call(rbind.data.frame, list_abundances)

```

# Plot the simulated abundances over time using ggplot2
```{r}
ggplot(data_abundances, aes(x = time, y = abundance, colour = factor(sim))) +
  geom_line() +
  labs(
    x = "Time", y = "Species abundance",
    title = paste(
      n_sim, "simulated abundances using our own linear function",
      "with slope", slope
    )
  ) +
  scale_y_continuous(limits = c(0, NA)) +
  scale_x_continuous(breaks = seq(0, n_time_points, 5)) +
  theme_minimal() +
  theme(legend.position = "")
```

