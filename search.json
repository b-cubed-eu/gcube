[{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement b-cubedsupport@meisebotanicgarden.. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to gcube","title":"Contributing to gcube","text":"outlines propose change gcube. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to gcube","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to gcube","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to gcube","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"b-cubed-eu/gcube\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to gcube","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to gcube","text":"Please note gcube project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Research Institute Nature Forest (INBO) Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"create-virtual-species","dir":"Articles","previous_headings":"","what":"Create virtual species","title":"Create occurrence cubes for virtual species","text":"Virtual species can created using virtualspecies R package (Leroy et al., 2015). basic example create virtual species. additional options comprehensive guide, refer package documentation tutorial available .","code":"# Load packages library(gcube)  library(geodata)        # get bioclimatic data library(virtualspecies) # generate virtual species  library(sf)             # work with spatial objects library(terra)          # work with raster data library(ggplot2)        # data visualisation"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-1-download-worldclim-data","dir":"Articles","previous_headings":"Create virtual species","what":"Step 1: Download WorldClim Data","title":"Create occurrence cubes for virtual species","text":"first obtain WorldClim bioclimatic data 10-minute resolution.","code":"# Download bioclimatic data worldclim <- worldclim_global(var = \"bio\", res = 10, path = tempdir())"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-2-define-the-region-of-interest","dir":"Articles","previous_headings":"Create virtual species","what":"Step 2: Define the region of interest","title":"Create occurrence cubes for virtual species","text":"define extent Western Palearctic crop climate data.","code":"# Western Palearctic wp <- terra::ext(-15, 65, 30, 75)  # Crop climate data worldclim <- terra::crop(worldclim, wp)"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-3-select-relevant-bioclimatic-variables","dir":"Articles","previous_headings":"Create virtual species","what":"Step 3: Select relevant bioclimatic variables","title":"Create occurrence cubes for virtual species","text":"select subset bioclimatic variables: bio2, bio5, bio6, bio13, bio14, bio15.","code":"# Specify variables bio_vars <- c(\"bio2\", \"bio5\", \"bio6\", \"bio13\", \"bio14\", \"bio15\")  # Select variables bio_string <- paste0(\"bio_\", sub(\"bio\", \"\", bio_vars), collapse = \"|\") bio_vars_selected <- names(worldclim)[grepl(bio_string, names(worldclim))]  # Subset climate data worldclim_vars <- worldclim[[bio_vars_selected]]"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-4-generate-a-virtual-species","dir":"Articles","previous_headings":"Create virtual species","what":"Step 4: Generate a virtual species","title":"Create occurrence cubes for virtual species","text":"create random virtual species based selected bioclimatic variables.","code":"set.seed(123)  # Generate random virtual species virtual_species <- generateRandomSp(worldclim_vars) #> Reading raster values. If it fails for very large rasters, use arguments 'sample.points = TRUE' and define a number of points to sample with 'nb.point'. #>  - Perfoming the pca #>  - Defining the response of the species along PCA axes #>  - Calculating suitability values #>    The final environmental suitability was rescaled between 0 and 1. #>                   To disable, set argument rescale = FALSE #>  - Converting into Presence - Absence #>    --- Generating a random value of beta for the logistic conversion #>    --- Determing species.prevalence automatically according to alpha and beta #>    Logistic conversion finished: #>                #> - beta = 0.194194194194194 #> - alpha = -0.1 #> - species prevalence =0.770632849948426"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-5-apply-a-geographical-limit","dir":"Articles","previous_headings":"Create virtual species","what":"Step 5: Apply a geographical limit","title":"Create occurrence cubes for virtual species","text":"limit species distribution United Kingdom Ireland.","code":"# Limit distribution virtual_distribution <- limitDistribution(   x = virtual_species,   geographical.limit = \"country\",   area = c(\"United Kingdom\", \"Ireland\") ) #> Warning: [rasterize] unexpected additional argument(s): silent"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-6-sample-occurrences","dir":"Articles","previous_headings":"Create virtual species","what":"Step 6: Sample occurrences","title":"Create occurrence cubes for virtual species","text":"sample 150 occurrences restricted distribution detection probability 0.8 using virtualspecies::sampleOccurrences() function. Detection probability sampling bias can introduced similar sample_observations().","code":"?virtualspecies::sampleOccurrences # Sample from virtual species distribution virtual_sample <- sampleOccurrences(   virtual_distribution,   n = 150,   detection.probability = 0.8 )"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"grid-designation-with-gcube","dir":"Articles","previous_headings":"","what":"Grid designation with gcube","title":"Create occurrence cubes for virtual species","text":"Now can create occurrence cube virtual species important step, make virtualspecies output compatible gcube input. done using virtualsample_to_sf() function. grid designation, see also tutorial 3. Specifying grid designation process.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-1-convert-sampled-points-to-sf-format","dir":"Articles","previous_headings":"Grid designation with gcube","what":"Step 1: Convert sampled points to sf format","title":"Create occurrence cubes for virtual species","text":"transform sampled points virtualspecies object can used gcube virtualsample_to_sf() function. Optional: Extract values raster can also extract raster values transforming sample data. instance, extracting suitability occurrence probability can helpful downstream analysis. transform detected points sf object LAEA Europe CRS (EPSG:3035).","code":"?virtualsample_to_sf # Transform virtual samples to sf object detections_df_raw <- virtualsample_to_sf(virtual_sample) detections_df_raw #> Simple feature collection with 150 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -9.25 ymin: 50.58333 xmax: 1.416667 ymax: 58.25 #> Geodetic CRS:  WGS 84 #> First 10 features: #>       id observed                    geometry #> 1  62966     TRUE      POINT (-0.75 53.08333) #> 2  60516     TRUE  POINT (-9.083333 53.91667) #> 3  63937     TRUE      POINT (1.083333 52.75) #> 4  59607     TRUE    POINT (-0.5833333 54.25) #> 5  66802     TRUE     POINT (-1.416667 51.75) #> 6  65795     TRUE      POINT (-9.25 52.08333) #> 7  60087     TRUE POINT (-0.5833333 54.08333) #> 8  55755     TRUE  POINT (-2.583333 55.58333) #> 9  54310     TRUE  POINT (-3.416667 56.08333) #> 10 56230     TRUE  POINT (-3.416667 55.41667) # Rename raster layers for clear output names(virtual_species$suitab.raster) <- \"suitability\" names(virtual_species$probability.of.occurrence) <- \"occ_prob\"  # Transform virtual samples and extract values virtualsample_to_sf(   virtual_sample,   raster_lyr = c(virtual_species$suitab.raster,                  virtual_species$probability.of.occurrence) ) #> Simple feature collection with 150 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -9.25 ymin: 50.58333 xmax: 1.416667 ymax: 58.25 #> Geodetic CRS:  WGS 84 #> First 10 features: #>       id observed suitability  occ_prob                    geometry #> 1  62966     TRUE 0.608657235 0.9843980      POINT (-0.75 53.08333) #> 2  60516     TRUE 0.081922322 0.2455073  POINT (-9.083333 53.91667) #> 3  63937     TRUE 0.481108846 0.9463000      POINT (1.083333 52.75) #> 4  59607     TRUE 0.375077019 0.8592202    POINT (-0.5833333 54.25) #> 5  66802     TRUE 0.516553006 0.9617124     POINT (-1.416667 51.75) #> 6  65795     TRUE 0.019556962 0.1485053      POINT (-9.25 52.08333) #> 7  60087     TRUE 0.354688757 0.8327085 POINT (-0.5833333 54.08333) #> 8  55755     TRUE 0.294534380 0.7317269  POINT (-2.583333 55.58333) #> 9  54310     TRUE 0.248244943 0.6319305  POINT (-3.416667 56.08333) #> 10 56230     TRUE 0.004863729 0.1308681  POINT (-3.416667 55.41667) # Transform CRS detections_df_transformed <- st_transform(detections_df_raw, crs = 3035)"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-2-add-coordinate-uncertainty","dir":"Articles","previous_headings":"Grid designation with gcube","what":"Step 2: Add coordinate uncertainty","title":"Create occurrence cubes for virtual species","text":"See also tutorial 2. Simulating detection process. keep detected occurrences using filter_observations() function. Optionally, can add coordinate uncertainty using add_coordinate_uncertainty() function. add 25 m uncertainty observation.","code":"detections_df <- filter_observations(detections_df_transformed) # Add coordinate uncertainty observations_df <- add_coordinate_uncertainty(   observations = detections_df,   coords_uncertainty_meters = 25 )"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-3-specify-reference-grid","dir":"Articles","previous_headings":"Grid designation with gcube","what":"Step 3: Specify reference grid","title":"Create occurrence cubes for virtual species","text":"also need grid. observation designated grid cell. can provide grid (e.g. EEA reference grid Europe). example create simple grid around sampled points. grid looks like .","code":"# Create reference grid buffered_observations <- st_buffer(observations_df, 25) cube_grid <- st_make_grid(   buffered_observations,   n = c(20, 20),   square = TRUE ) %>%   st_sf() ggplot() +   geom_sf(data = observations_df) +   geom_sf(data = cube_grid, alpha = 0) +   coord_sf(datum = 3035) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/cube-for-virtual-species.html","id":"step-4-perform-grid-designation","dir":"Articles","previous_headings":"Grid designation with gcube","what":"Step 4: Perform grid designation","title":"Create occurrence cubes for virtual species","text":"perform grid designation aggregated version visualisation purposes. Lets visualise samples taken. Note distinction made zeroes NA values. Every absence gets zero value.","code":"# Perform grid designation occurrence_cube_df <- grid_designation(   observations_df,   cube_grid,   seed = 123 ) #> Warning in sample_from_uniform_circle(observations = observations, missing_uncertainty = missing_uncertainty, : No column `time_point` present! #> Assuming only a single time point. # Get sampled points from uncertainty circle sampled_points <- grid_designation(   observations_df,   cube_grid,   seed = 123,   aggregate = FALSE ) #> Warning in sample_from_uniform_circle(observations = observations, missing_uncertainty = missing_uncertainty, : No column `time_point` present! #> Assuming only a single time point. ggplot() +   geom_sf(data = occurrence_cube_df,           alpha = 0) +   geom_sf_text(data = occurrence_cube_df,                aes(label = n)) +   geom_sf(data = sampled_points,           colour = \"blue\") +   coord_sf(datum = 3035) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"method","dir":"Articles","previous_headings":"","what":"Method","title":"Grid designation for custom datasets","text":"generate point within circle radius rr around central coordinate (x0,y0)(x_0, y_0), use polar coordinates convert Cartesian coordinates. Sample random angle uniform distribution 𝒰\\mathcal{U}: θ∼𝒰(0,2π) \\theta \\sim \\mathcal{U}(0, 2\\pi) Sample random radius scaled square root ensure uniform point density: r′=𝒰(0,1)⋅r r' = \\sqrt{\\mathcal{U}(0, 1)} \\cdot r Convert Cartesian coordinates: x=x0+r′cos⁡(θ) x = x_0 + r' \\cos(\\theta) y=y0+r′sin⁡(θ) y = y_0 + r' \\sin(\\theta)","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"coordinate-reference-system-considerations","dir":"Articles","previous_headings":"","what":"Coordinate Reference System Considerations","title":"Grid designation for custom datasets","text":"method applying formula depends unit system CRS.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"projected-crs-e-g--utm","dir":"Articles","previous_headings":"Coordinate Reference System Considerations","what":"Projected CRS (e.g., UTM)","title":"Grid designation for custom datasets","text":"Projected systems use meters linear units, polar formula can applied directly. accurate straightforward method used whenever data projected CRS.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"geographic-crs-e-g--wgs84","dir":"Articles","previous_headings":"Coordinate Reference System Considerations","what":"Geographic CRS (e.g., WGS84)","title":"Grid designation for custom datasets","text":"Geographic systems use degrees, meters. Therefore, uncertainty radius meters must converted degrees using approximations based latitude: 1 degree latitude ≈ 111,320 meters 1 degree longitude ≈ 111,320⋅cos⁡(latitude)111{,}320 \\cdot \\cos(\\text{latitude}) meters Use formulas convert meters degrees: approximations may introduce distortion, especially high latitudes. ⚠️ Tip: Always prefer using projected CRS (like UTM) grid designation available. minimizes distortion simplifies calculations. Use geographic CRS (e.g., WGS84) dataset explicitly requires projected CRS available.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"getting-started-with-gcube","dir":"Articles","previous_headings":"","what":"Getting started with gcube","title":"Grid designation for custom datasets","text":"example, show gcube can used perform grid designation custom ecological dataset.","code":"# Load packages library(gcube)  library(frictionless) # Load example dataset library(ggplot2)      # Data visualisation library(dplyr)        # Data wrangling library(sf)           # Working with spatial data"},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"get-example-data","dir":"Articles","previous_headings":"Getting started with gcube","what":"Get example data","title":"Grid designation for custom datasets","text":"reference grid, load MGRS grid 10 km scale b3data data package. Consider following synthetic observation dataset three species observed across three different years. row represents record spatial coordinates associated uncertainty meters. reference grid observation data use projected CRS, ensures distances buffer sizes accurately computed. visualise data uncertainty circles.","code":"# Read data from repository mgrs10_belgium <- st_read(   \"https://zenodo.org/records/15211029/files/mgrs10_refgrid_belgium.gpkg\",   quiet = TRUE ) head(mgrs10_belgium) #> Simple feature collection with 6 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 460000.1 ymin: 5620000 xmax: 480000.1 ymax: 5670000 #> Projected CRS: WGS 84 / UTM zone 31N #>   mgrscode                           geom #> 1  31UDS65 POLYGON ((470000.1 5651000,... #> 2  31UDS66 POLYGON ((470000.1 5661000,... #> 3  31UDS72 POLYGON ((480000 5621000, 4... #> 4  31UDS73 POLYGON ((480000.1 5631000,... #> 5  31UDS74 POLYGON ((480000.1 5641000,... #> 6  31UDS75 POLYGON ((480000.1 5651000,... # Simulate 9 observation records: 3 species x 3 years example_data <- data.frame(   species = rep(c(\"species1\", \"species2\", \"species3\"), each = 3),   time_point = rep(2020:2022, times = 3),   lat = c(     5683521, 5613261, 5533663,     5672768, 5559184, 5670045,     5628962, 5651001, 5587280   ),   long = c(     512309.4, 560722.6, 700880.4,     649960.8, 688510.1, 641283.4,     502044.7, 568593.9, 566011.5   ),   coordinateUncertaintyInMeters = c(     1000, 2500, 5000,     1500, 10000, 8000,     4000, 2500, 3500   ) ) %>%   st_as_sf(coords = c(\"long\", \"lat\"), crs = st_crs(mgrs10_belgium))  example_data #> Simple feature collection with 9 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 502044.7 ymin: 5533663 xmax: 700880.4 ymax: 5683521 #> Projected CRS: WGS 84 / UTM zone 31N #>    species time_point coordinateUncertaintyInMeters                 geometry #> 1 species1       2020                          1000 POINT (512309.4 5683521) #> 2 species1       2021                          2500 POINT (560722.6 5613261) #> 3 species1       2022                          5000 POINT (700880.4 5533663) #> 4 species2       2020                          1500 POINT (649960.8 5672768) #> 5 species2       2021                         10000 POINT (688510.1 5559184) #> 6 species2       2022                          8000 POINT (641283.4 5670045) #> 7 species3       2020                          4000 POINT (502044.7 5628962) #> 8 species3       2021                          2500 POINT (568593.9 5651001) #> 9 species3       2022                          3500 POINT (566011.5 5587280) # Create sf object with uncertainty circles buffered_observations <- st_buffer(   example_data,   example_data$coordinateUncertaintyInMeters )  # Visualise ggplot() +   geom_sf(data = mgrs10_belgium) +   geom_sf(data = buffered_observations,           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = example_data, aes(colour = species))"},{"path":"https://b-cubed-eu.github.io/gcube/articles/custom-grid-designation.html","id":"grid-designation","dir":"Articles","previous_headings":"Getting started with gcube","what":"Grid designation","title":"Grid designation for custom datasets","text":"perform grid designation, iterate species, filter corresponding observations, apply grid_designation() generate species-specific data cube. improved performance, especially larger datasets, consider using vectorized approaches lapply() purrr::map() instead explicit loops. select occupied grid cells. visualise final occurrence cube. Since three species occurrences per year spread whole grid, see three occupied grid cells per year.","code":"# Get species taxa <- sort(unique(example_data$species))  # Create empty list occurrence_cube_list <- vector(mode = \"list\", length = length(taxa))  # Loop over species for (i in seq_along(taxa)) {   # Get species   taxon <- taxa[i]    # Filter data   taxon_data <- example_data %>%     filter(taxon == species)    # Perform grid designation   taxon_cube <- grid_designation(     observations = taxon_data,     grid = mgrs10_belgium,     seed = 123   )    # Add species column   taxon_cube$species <- taxon    # Add species cube to list   occurrence_cube_list[[i]] <- taxon_cube }  # Combine species cubes occurrence_cube_full <- bind_rows(occurrence_cube_list) occurrence_cube_df <- occurrence_cube_full %>%   filter(n != 0) ggplot(occurrence_cube_df) +   geom_sf(data = mgrs10_belgium) +   geom_sf(aes(fill = species)) +   facet_wrap(~time_point, nrow = 2)"},{"path":"https://b-cubed-eu.github.io/gcube/articles/detection-process.html","id":"input","dir":"Articles","previous_headings":"","what":"Input","title":"2. Simulating the detection process","text":"functions set single polygon input enough go workflow using default arguments. user can change arguments allow flexibility. input, create polygon simulate occurrences. represents spatial extend species. polygon looks like .  can example sample randomly within polygon 6 time points use random walk time initial average number occurrences equal 100 (see see tutorial 1 simulating occurrence process). spatial distribution occurrences time point","code":"polygon <- st_polygon(list(cbind(c(500, 1000, 1000, 600, 200, 100, 500),                                  c(200, 100, 700, 1000, 900, 500, 200)))) ggplot() +   geom_sf(data = polygon) +   theme_minimal() occurrences_df <- simulate_occurrences(   species_range = polygon,   initial_average_occurrences = 100,   n_time_points = 6,   temporal_function = simulate_random_walk,   sd_step = 1,   spatial_pattern = \"random\",   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_sf(data = polygon) +   geom_sf(data = occurrences_df) +   facet_wrap(~time_point, nrow = 2) +   ggtitle(\"Distribution of occurrences for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/detection-process.html","id":"detect-occurrences","dir":"Articles","previous_headings":"","what":"Detect occurrences","title":"2. Simulating the detection process","text":"occurrences, occurrences generally observed. detection occurrences depends detection probability species sampling bias (includes sampling bias effort). process can simulated using sample_observations() function. observation detection probability value (=observations) bias weight depending spatial distribution. combination detection probability bias weight results sampling probability used decide whether occurrence detected using (rbinom(1, 1, sampling_probability)). bias 3 options: \"no_bias\", \"polygon\" \"manual\". \"no_bias\", detection probability value decide whether occurrence observed . \"polygon\", bias weights depend location inside outside given polygon certain bias strength. can visualise using supporting function apply_polygon_sampling_bias(). Lets say road across polygon. Define road width. Create road points. Create road-like polygon within given polygon. Plot result.  can say occurrences road 2x larger probability detected. see occurrences road twice bias weights occurrences.  \"manual\", bias weights depend location inside grid cells given grid cell value. can visualise using supporting function apply_manual_sampling_bias(). Lets create grid give random bias weights cell. Plot grid.  use supporting function. use time point 1. indeed see higher bias weights occurrences higher values grid cells.","code":"?sample_observations ?apply_polygon_sampling_bias road_width <- 50 road_points <- rbind(c(100, 500), c(1000, 500)) road_polygon <- st_linestring(road_points) %>%   st_buffer(road_width) %>%   st_intersection(polygon) %>%   st_polygon() %>%   st_sfc() %>%   st_as_sf() %>%   rename(geometry = x) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   theme_minimal() occurrence_bias_df1 <- apply_polygon_sampling_bias(   occurrences_df,   bias_area = road_polygon,   bias_strength = 2 ) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = occurrence_bias_df1,           aes(colour = factor(round(bias_weight, 3)))) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of occurrences for each time point\",        colour = \"bias_weight\") +   theme_minimal() ?apply_manual_sampling_bias grid <- st_make_grid(   polygon,   n = c(10, 10),   square = TRUE ) %>%   st_sf() set.seed(123) grid$bias_weight <- runif(nrow(grid), min = 0, max = 1) ggplot() +   geom_sf(data = polygon) +   geom_sf(data = grid, alpha = 0) +   geom_sf_text(data = grid, aes(label = round(bias_weight, 2))) +   theme_minimal() occurrence_bias_df2 <- apply_manual_sampling_bias(   occurrences_df %>% dplyr::filter(time_point == 1),   bias_weights = grid ) ggplot() +   geom_sf(data = polygon) +   geom_sf(data = grid, alpha = 0) +   geom_sf(data = occurrence_bias_df2,           aes(colour = bias_weight)) +   geom_sf_text(data = grid, aes(label = round(bias_weight, 2))) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/detection-process.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"2. Simulating the detection process","text":"Now know supporting functions work, can simulate detection process using sample_observations() function. can example state species 0.9 detection probability time say small chance detect road. see lot occurrences detected due high detection probability, case road detected.","code":"detections_df_raw <- sample_observations(   occurrences_df,   detection_probability = 0.9,   sampling_bias = \"polygon\",   bias_area = road_polygon,   bias_strength = 0.1,   seed = 123 ) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = detections_df_raw,           aes(colour = observed)) +   scale_colour_manual(values = c(\"blue\", \"red\")) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of occurrences for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/detection-process.html","id":"adding-coordinate-uncertainty","dir":"Articles","previous_headings":"","what":"Adding coordinate uncertainty","title":"2. Simulating the detection process","text":"mimic real life data collection, can finally add coordinate uncertainty observations. keep detected occurrences previous example. can filter dplyr::filter(). can use function filter_observations(). add coordinate uncertainty observations using add_coordinate_uncertainty() function. can add value observations vector single value observation. Lets add 25 meters uncertainty observation. Created sf object uncertainty circles visualise .","code":"detections_df1 <- detections_df_raw %>%   dplyr::filter(observed == TRUE) ?filter_observations detections_df2 <- filter_observations(   observations_total = detections_df_raw )  # Do we get the same result? identical(detections_df1, detections_df2) #> [1] TRUE ?add_coordinate_uncertainty observations_df <- add_coordinate_uncertainty(   observations = detections_df2,   coords_uncertainty_meters = 25 ) buffered_observations <- st_buffer(   observations_df,   observations_df$coordinateUncertaintyInMeters )  ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = buffered_observations,           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = observations_df, colour = \"firebrick\", size = 0.8) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of observations for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/grid-designation-process.html","id":"input","dir":"Articles","previous_headings":"","what":"Input","title":"3. Specifying the grid designation process","text":"functions set single polygon input enough go workflow using default arguments. user can change arguments allow flexibility. input, create polygon simulate occurrences. represents spatial extend species. polygon looks like .  Also consider road across polygon. result looks like .  can example sample randomly within polygon 6 time points use random walk time initial average number occurrences equal 100 (see tutorial 1 simulating occurrence process). spatial distribution occurrences time point  detect occurrences using 0.9 detection probability bias 0.1 detect occurrences road (see tutorial 2 simulating detection process). spatial distribution occurrences time point  keep detected occurrences add 25 meters uncertainty observation (see tutorial 2 simulating detection process). final observations uncertainty circles look like .","code":"polygon <- st_polygon(list(cbind(c(500, 1000, 1000, 600, 200, 100, 500),                                  c(200, 100, 700, 1000, 900, 500, 200)))) ggplot() +   geom_sf(data = polygon) +   theme_minimal() # Define the road width road_width <- 50  # Create road points road_points <- rbind(c(100, 500), c(1000, 500))  # Create road-like polygon within the given polygon road_polygon <- st_linestring(road_points) %>%   st_buffer(road_width) %>%   st_intersection(polygon) %>%   st_polygon() %>%   st_sfc() %>%   st_as_sf() %>%   rename(geometry = x) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   theme_minimal() occurrences_df <- simulate_occurrences(   species_range = polygon,   initial_average_occurrences = 100,   n_time_points = 6,   temporal_function = simulate_random_walk,   sd_step = 1,   spatial_pattern = \"random\",   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_sf(data = polygon) +   geom_sf(data = occurrences_df) +   facet_wrap(~time_point, nrow = 2) +   ggtitle(\"Distribution of occurrences for each time point\") +   theme_minimal() detections_df_raw <- sample_observations(   occurrences_df,   detection_probability = 0.9,   sampling_bias = \"polygon\",   bias_area = road_polygon,   bias_strength = 0.1,   seed = 123 ) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = detections_df_raw,           aes(colour = observed)) +   scale_colour_manual(values = c(\"blue\", \"red\")) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of occurrences for each time point\") +   theme_minimal() # Keep detected occurrences detections_df <- filter_observations(   observations_total = detections_df_raw )  # Add 25 m coordinate uncertainty observations_df <- add_coordinate_uncertainty(   observations = detections_df,   coords_uncertainty_meters = 25 ) # Create sf object with uncertainty circles buffered_observations <- st_buffer(   observations_df,   observations_df$coordinateUncertaintyInMeters )  # Visualise ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = buffered_observations,           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = observations_df, colour = \"firebrick\", size = 0.8) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of observations for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/grid-designation-process.html","id":"grid-designation","dir":"Articles","previous_headings":"","what":"Grid designation","title":"3. Specifying the grid designation process","text":"Now can make data cube observations taking account uncertainty. can create grid using grid_designation() function. also need grid. observation designated grid cell. grid looks like .  grid designation take coordinate uncertainty account? default \"uniform\" randomisation random point within uncertainty circle taken location observation. point designated overlapping grid cell. Another option \"normal\" point sampled bivariate Normal distribution means equal observation point variance equal (-coordinateUncertaintyInMeters^2) / (2 * log(1 - p_norm)) p_norm % possible samples Normal distribution fall within uncertainty circle. can visualised using supporting functions. Lets create single random point 25 meter coordinate uncertainty. sample 1000 times using uniform normal randomisation look difference methods. take 1000 samples uniform randomisation. take 1000 samples normal randomisation case uniform randomisation, see samples everywhere evenly spread within uncertainty circle.  case normal randomisation, see samples outside uncertainty circle. 0.05 (=1 - p_norm) %. also see samples closer central point.  coordinate uncertainty provided, original observation point used grid designation.","code":"?grid_designation cube_grid <- st_make_grid(   st_buffer(polygon, 25),   n = c(20, 20),   square = TRUE ) %>%   st_sf() ggplot() +   geom_sf(data = polygon) +   geom_sf(data = cube_grid, alpha = 0) +   theme_minimal() ?sample_from_uniform_circle ?sample_from_binormal_circle # Create point and add coordinate uncertainty point_df <- tibble(   x = 200,   y = 500,   time_point = 1,   coordinateUncertaintyInMeters = 25 ) %>%   st_as_sf(coords = c(\"x\", \"y\"))  # Number of simulations n_sim <- 1000 list_samples_uniform <- vector(\"list\", length = n_sim) for (i in seq_len(n_sim)) {   sampled_point_uniform <- sample_from_uniform_circle(point_df)   sampled_point_uniform$sim <- i   list_samples_uniform[[i]] <- sampled_point_uniform } samples_uniform_df <- do.call(rbind.data.frame, list_samples_uniform) list_samples_normal <- vector(\"list\", length = n_sim) for (i in seq_len(n_sim)) {   sampled_point_normal <- sample_from_binormal_circle(point_df, p_norm = 0.95)   sampled_point_normal$sim <- i   list_samples_normal[[i]] <- sampled_point_normal } samples_normal_df <- do.call(rbind.data.frame, list_samples_normal) # Get coordinates coordinates_uniform_df <- data.frame(st_coordinates(samples_uniform_df)) coordinates_normal_df <- data.frame(st_coordinates(samples_normal_df)) coordinates_point_df <- data.frame(st_coordinates(point_df))  # Create figures for both randomisations scatter_uniform <- ggplot() +   geom_point(data = coordinates_uniform_df,              aes(x = X, y = Y),              colour = \"cornflowerblue\") +   geom_segment(data = coordinates_point_df,                aes(x = X, xend = X + 25,                    y = Y, yend = Y),                linewidth = 1.5, colour = \"darkgreen\") +   geom_label(aes(y = 503, x = 212.5, label = \"25 m\"), colour = \"black\",              size = 5) +   geom_point(data = coordinates_point_df,              aes(x = X, y = Y),              color = \"firebrick\", size = 2) +   coord_fixed() +   theme_minimal()  scatter_normal <- ggplot() +   geom_point(data = coordinates_normal_df,              aes(x = X, y = Y),              colour = \"cornflowerblue\") +   geom_segment(data = coordinates_point_df,                aes(x = X, xend = X + 25,                    y = Y, yend = Y),                linewidth = 1.5, colour = \"darkgreen\") +   geom_label(aes(y = 503, x = 212.5, label = \"25 m\"), colour = \"black\",              size = 5) +   stat_ellipse(data = coordinates_normal_df, aes(x = X, y = Y),                level = 0.975, linewidth = 1, color = \"firebrick\") +   geom_point(data = coordinates_point_df,              aes(x = X, y = Y),              color = \"firebrick\", size = 2) +   coord_fixed() +   theme_minimal() ggExtra::ggMarginal(scatter_uniform, type = \"histogram\") ggExtra::ggMarginal(scatter_normal, type = \"histogram\")"},{"path":"https://b-cubed-eu.github.io/gcube/articles/grid-designation-process.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"3. Specifying the grid designation process","text":"Now know use randomisation grid_designation(). default use uniform randomisation. create occurrence cube time point 1. grid cell (column cell_code) time point (column time_point), get number observations (column n, sampled within uncertainty circle) minimal coordinate uncertainty (column min_coord_uncertainty). latter 25 grid cell since observation coordinate uncertainty. Get sampled points within uncertainty circle setting aggregate = FALSE. Lets visualise samples taken time point 1. Note distinction made zeroes NA values! Every absence gets zero value.  Visualise minimal coordinate uncertainty time points 1 2.","code":"occurrence_cube_df <- grid_designation(   observations_df,   cube_grid,   seed = 123 ) head(occurrence_cube_df %>% st_drop_geometry()) #> # A tibble: 6 × 4 #>   time_point cell_code     n min_coord_uncertainty #>        <int> <chr>     <int>                 <dbl> #> 1          1 107           2                    25 #> 2          1 109           1                    25 #> 3          1 113           2                    25 #> 4          1 119           2                    25 #> 5          1 124           1                    25 #> 6          1 130           1                    25 sampled_points <- grid_designation(   observations_df,   cube_grid,   seed = 123,   aggregate = FALSE ) ggplot() +   geom_sf(data = polygon) +   geom_sf(data = occurrence_cube_df %>% dplyr::filter(time_point == 1),           alpha = 0) +   geom_sf_text(data = occurrence_cube_df %>% dplyr::filter(time_point == 1),                aes(label = n)) +   geom_sf(data = buffered_observations %>% dplyr::filter(time_point == 1),           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = sampled_points %>% dplyr::filter(time_point == 1),           colour = \"blue\") +   geom_sf(data = observations_df %>% dplyr::filter(time_point == 1),           colour = \"firebrick\") +   theme_minimal() ggplot() +   geom_sf(data = polygon) +   geom_sf(data = occurrence_cube_df %>% dplyr::filter(time_point %in% 1:2),           aes(fill = min_coord_uncertainty), alpha = 0.5) +   geom_sf_text(data = occurrence_cube_df %>% dplyr::filter(time_point %in% 1:2),                aes(label = n)) +   facet_wrap(~time_point) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/multi-species-approach.html","id":"spatial-extend","dir":"Articles","previous_headings":"","what":"Spatial extend","title":"4. Creating cubes for multiple species","text":"input, create polygon simulate occurrences. represents spatial extend species. polygon looks like .  Also consider road across polygon. result looks like .  also need grid. observation designated grid cell. grid looks like .","code":"polygon <- st_polygon(list(cbind(c(500, 1000, 1000, 600, 200, 100, 500),                                  c(200, 100, 700, 1000, 900, 500, 200)))) ggplot() +   geom_sf(data = polygon) +   theme_minimal() # Define the road width road_width <- 50  # Create road points road_points <- rbind(c(100, 500), c(1000, 500))  # Create road-like polygon within the given polygon road_polygon <- st_linestring(road_points) %>%   st_buffer(road_width) %>%   st_intersection(polygon) %>%   st_polygon() %>%   st_sfc() %>%   st_as_sf() %>%   rename(geometry = x) ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   theme_minimal() cube_grid <- st_make_grid(   st_buffer(polygon, 50),   n = c(20, 20),   square = TRUE ) %>%   st_sf() ggplot() +   geom_sf(data = polygon) +   geom_sf(data = cube_grid, alpha = 0) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/multi-species-approach.html","id":"input-dataframe","dir":"Articles","previous_headings":"","what":"Input dataframe","title":"4. Creating cubes for multiple species","text":"generate cubes multiple species efficiently, create dataframe row represents different species specify arguments used main cube simulation functions, viz simulate_occurrences(), sample_observations(), filter_observations(), add_coordinate_uncertainty(), grid_designation(), separate columns. values within columns can change species. move , add taxonomic hierarchy dataframe. might used calculate phylogenetic indicators upstream just complete comprehensible dataset cube generation. generate taxonomic hierarchy using generate_taxonomy() function. need specify least number species, genera families. Higher taxonomic levels default 1. can add taxonomic hierarchy dataframe function arguments get complete dataset. can give dataframe directly input generate_taxonomy(), create species taxonomic hierarchy row.","code":"# Create dataframe with simulation function arguments multi_species_args <- tibble(   species_range = rep(list(polygon), 6),   initial_average_occurrences = rep(c(50, 100, 500), 2),   n_time_points = rep(6, 6),   temporal_function = c(simulate_random_walk, simulate_random_walk, rep(NA, 4)),   sd_step = c(1, 1, rep(NA, 4)),   spatial_pattern = c(rep(\"random\", 3), rep(\"clustered\", 3)),   detection_probability = rep(c(0.8, 0.9, 1), 2),   sampling_bias = c(rep(\"polygon\", 3), rep(\"no_bias\", 3)),   bias_area = c(rep(list(road_polygon), 3), rep(NA, 3)),   bias_strength = c(c(0.1, 0.2, 0.3), rep(1, 3)),   coords_uncertainty_meters = rep(c(25, 30, 50), 2),   grid = rep(list(cube_grid), 6),   seed = 123 )  # How does this dataframe look like? glimpse(multi_species_args) #> Rows: 6 #> Columns: 13 #> $ species_range               <list> [POLYGON ((500 200, 1000 100...], [POLYGO… #> $ initial_average_occurrences <dbl> 50, 100, 500, 50, 100, 500 #> $ n_time_points               <dbl> 6, 6, 6, 6, 6, 6 #> $ temporal_function           <list> function (initial_average_occurrences = 50… #> $ sd_step                     <dbl> 1, 1, NA, NA, NA, NA #> $ spatial_pattern             <chr> \"random\", \"random\", \"random\", \"clustered\",… #> $ detection_probability       <dbl> 0.8, 0.9, 1.0, 0.8, 0.9, 1.0 #> $ sampling_bias               <chr> \"polygon\", \"polygon\", \"polygon\", \"no_bias… #> $ bias_area                   <list> [<sf[1 x 1]>], [<sf[1 x 1]>], [<sf[1 x 1]>… #> $ bias_strength               <dbl> 0.1, 0.2, 0.3, 1.0, 1.0, 1.0 #> $ coords_uncertainty_meters   <dbl> 25, 30, 50, 25, 30, 50 #> $ grid                        <list> [<sf[400 x 1]>], [<sf[400 x 1]>], [<sf[400… #> $ seed                        <dbl> 123, 123, 123, 123, 123, 123 ?generate_taxonomy # Define number of species n_specs <- nrow(multi_species_args)  # Generate taxonomic hierarchy taxonomy <- generate_taxonomy(   num_species = n_specs,   num_genera = 4,   num_families = 2,   seed = 123 )  # How does the taxonomic hierarchy look like? taxonomy #>    species species_key  genus  family  order  class  phylum  kingdom #> 1 species1           1 genus3 family1 order1 class1 phylum1 kingdom1 #> 2 species2           2 genus3 family1 order1 class1 phylum1 kingdom1 #> 3 species3           3 genus3 family1 order1 class1 phylum1 kingdom1 #> 4 species4           4 genus2 family2 order1 class1 phylum1 kingdom1 #> 5 species5           5 genus3 family1 order1 class1 phylum1 kingdom1 #> 6 species6           6 genus2 family2 order1 class1 phylum1 kingdom1 # Combine dataframes multi_species_dataset1 <- cbind(taxonomy, multi_species_args) %>%   as_tibble() # To compare with dataset2, see next chunk  # How does the dataset look like? glimpse(multi_species_dataset1) #> Rows: 6 #> Columns: 21 #> $ species                     <chr> \"species1\", \"species2\", \"species3\", \"speci… #> $ species_key                 <int> 1, 2, 3, 4, 5, 6 #> $ genus                       <chr> \"genus3\", \"genus3\", \"genus3\", \"genus2\", \"g… #> $ family                      <chr> \"family1\", \"family1\", \"family1\", \"family2\"… #> $ order                       <chr> \"order1\", \"order1\", \"order1\", \"order1\", \"o… #> $ class                       <chr> \"class1\", \"class1\", \"class1\", \"class1\", \"c… #> $ phylum                      <chr> \"phylum1\", \"phylum1\", \"phylum1\", \"phylum1\"… #> $ kingdom                     <chr> \"kingdom1\", \"kingdom1\", \"kingdom1\", \"kingd… #> $ species_range               <list> [POLYGON ((500 200, 1000 100...], [POLYGON… #> $ initial_average_occurrences <dbl> 50, 100, 500, 50, 100, 500 #> $ n_time_points               <dbl> 6, 6, 6, 6, 6, 6 #> $ temporal_function           <list> function (initial_average_occurrences = 5… #> $ sd_step                     <dbl> 1, 1, NA, NA, NA, NA #> $ spatial_pattern             <chr> \"random\", \"random\", \"random\", \"clustered\",… #> $ detection_probability       <dbl> 0.8, 0.9, 1.0, 0.8, 0.9, 1.0 #> $ sampling_bias               <chr> \"polygon\", \"polygon\", \"polygon\", \"no_bias\"… #> $ bias_area                   <list> [<sf[1 x 1]>], [<sf[1 x 1]>], [<sf[1 x 1]… #> $ bias_strength               <dbl> 0.1, 0.2, 0.3, 1.0, 1.0, 1.0 #> $ coords_uncertainty_meters   <dbl> 25, 30, 50, 25, 30, 50 #> $ grid                        <list> [<sf[400 x 1]>], [<sf[400 x 1]>], [<sf[400… #> $ seed                        <dbl> 123, 123, 123, 123, 123, 123 # Use dataframe as input to generate taxonomic hierarchy multi_species_dataset2 <- generate_taxonomy(   num_species = multi_species_args,   num_genera = 4,   num_families = 2,   seed = 123 )  # Do we get the same result? identical(multi_species_dataset1, multi_species_dataset2) #> [1] TRUE"},{"path":"https://b-cubed-eu.github.io/gcube/articles/multi-species-approach.html","id":"mapping-the-simulation-process-over-each-rowspecies","dir":"Articles","previous_headings":"","what":"Mapping the simulation process over each row/species","title":"4. Creating cubes for multiple species","text":"cube simulation function mapping companion. mapping functions apply single-species operations row using purrr::pmap() strategy. output mapping functions stored list-column default ensure efficient transition simulation functions. can also pipe functions. mapping function also argument nested. nested = TRUE (default), retain list-column containing calculated sf objects calculated simulate_occurrences(). nested = FALSE, list-column expanded rows columns. example map_grid_designation(), can recognise columns produced grid_designation(). Nested list-columns useful calculation simulation workflow shown . Calculation visualisation output easily performed unnested list-columns. Finally, mapping functions allow column names deviate argument names single-species companions. names list provided mapping functions know columns match arguments. mapping functions retain original column names output. rename example three column names longer match argument names single-species functions: species_range →\\rightarrow polygon (argument simulate_occurrences()) detection_probability →\\rightarrow det_prob (argument sample_observations()) grid →\\rightarrow raster (argument grid_designation()) need create named list match new column names argument names. names argument names single-species functions values deviating column names. perform workflow use arg_list argument convert names. can see workflow works expected column names original (changed) names input dataframe.","code":"# Creates occurrences list-column with simulated occurrences map_sim_occ_df <- map_simulate_occurrences(df = multi_species_dataset2) #> [1] [using unconditional Gaussian simulation] #> [2] [using unconditional Gaussian simulation] #> [3] [using unconditional Gaussian simulation] #> [4] [using unconditional Gaussian simulation] #> [5] [using unconditional Gaussian simulation] #> [6] [using unconditional Gaussian simulation]  # Creates observations_total list-column with sampled observations map_samp_obs_df <- map_sample_observations(df = map_sim_occ_df)  # Creates observations list-column with detected observations map_filter_obs_df <- map_filter_observations(df = map_samp_obs_df)  # Add coordinateUncertaintyInMeters column to observations list-column map_obs_uncertainty_df <- map_add_coordinate_uncertainty(df = map_filter_obs_df)  # Creates occurrence_cube_df list-column with final data cubes map_occ_cube_df1 <- map_grid_designation(df = map_obs_uncertainty_df)  # How does the final dataframe look like? glimpse(map_occ_cube_df1) #> Rows: 6 #> Columns: 25 #> $ species                     <chr> \"species1\", \"species2\", \"species3\", \"speci… #> $ species_key                 <int> 1, 2, 3, 4, 5, 6 #> $ genus                       <chr> \"genus3\", \"genus3\", \"genus3\", \"genus2\", \"g… #> $ family                      <chr> \"family1\", \"family1\", \"family1\", \"family2\"… #> $ order                       <chr> \"order1\", \"order1\", \"order1\", \"order1\", \"o… #> $ class                       <chr> \"class1\", \"class1\", \"class1\", \"class1\", \"c… #> $ phylum                      <chr> \"phylum1\", \"phylum1\", \"phylum1\", \"phylum1\"… #> $ kingdom                     <chr> \"kingdom1\", \"kingdom1\", \"kingdom1\", \"kingd… #> $ species_range               <list> [POLYGON ((500 200, 1000 100...], [POLYGON… #> $ initial_average_occurrences <dbl> 50, 100, 500, 50, 100, 500 #> $ n_time_points               <dbl> 6, 6, 6, 6, 6, 6 #> $ temporal_function           <list> function (initial_average_occurrences = 5… #> $ sd_step                     <dbl> 1, 1, NA, NA, NA, NA #> $ spatial_pattern             <chr> \"random\", \"random\", \"random\", \"clustered\",… #> $ detection_probability       <dbl> 0.8, 0.9, 1.0, 0.8, 0.9, 1.0 #> $ sampling_bias               <chr> \"polygon\", \"polygon\", \"polygon\", \"no_bias\"… #> $ bias_area                   <list> [<sf[1 x 1]>], [<sf[1 x 1]>], [<sf[1 x 1]… #> $ bias_strength               <dbl> 0.1, 0.2, 0.3, 1.0, 1.0, 1.0 #> $ coords_uncertainty_meters   <dbl> 25, 30, 50, 25, 30, 50 #> $ grid                        <list> [<sf[400 x 1]>], [<sf[400 x 1]>], [<sf[400… #> $ seed                        <dbl> 123, 123, 123, 123, 123, 123 #> $ occurrences                 <list> [<sf[304 x 3]>], [<sf[607 x 3]>], [<sf[302… #> $ observations_total          <list> [<sf[304 x 6]>], [<sf[607 x 6]>], [<sf[302… #> $ observations                <list> [<sf[191 x 7]>], [<sf[396 x 7]>], [<sf[210… #> $ occurrence_cube_df          <list> [<sf[2400 x 5]>], [<sf[2400 x 5]>], [<sf[… map_occ_cube_df2 <- multi_species_dataset2 %>%   map_simulate_occurrences() %>%   map_sample_observations() %>%   map_filter_observations() %>%   map_add_coordinate_uncertainty() %>%   map_grid_designation() #> [1] [using unconditional Gaussian simulation] #> [2] [using unconditional Gaussian simulation] #> [3] [using unconditional Gaussian simulation] #> [4] [using unconditional Gaussian simulation] #> [5] [using unconditional Gaussian simulation] #> [6] [using unconditional Gaussian simulation]  # Is the output the same as before? identical(map_occ_cube_df1, map_occ_cube_df2) #> [1] TRUE # Unnest list-column map_occ_cube_df_unnested <- map_grid_designation(   df = map_obs_uncertainty_df,   nested = FALSE )  # How does the dataset look like? glimpse(map_occ_cube_df_unnested) #> Rows: 14,400 #> Columns: 29 #> $ species                     <chr> \"species1\", \"species1\", \"species1\", \"speci… #> $ species_key                 <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … #> $ genus                       <chr> \"genus3\", \"genus3\", \"genus3\", \"genus3\", \"g… #> $ family                      <chr> \"family1\", \"family1\", \"family1\", \"family1\"… #> $ order                       <chr> \"order1\", \"order1\", \"order1\", \"order1\", \"o… #> $ class                       <chr> \"class1\", \"class1\", \"class1\", \"class1\", \"c… #> $ phylum                      <chr> \"phylum1\", \"phylum1\", \"phylum1\", \"phylum1\"… #> $ kingdom                     <chr> \"kingdom1\", \"kingdom1\", \"kingdom1\", \"kingd… #> $ species_range               <list> [POLYGON ((500 200, 1000 100...], [POLYGO… #> $ initial_average_occurrences <dbl> 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50… #> $ n_time_points               <dbl> 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, … #> $ temporal_function           <list> function (initial_average_occurrences = 5… #> $ sd_step                     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … #> $ spatial_pattern             <chr> \"random\", \"random\", \"random\", \"random\", \"r… #> $ detection_probability       <dbl> 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.… #> $ sampling_bias               <chr> \"polygon\", \"polygon\", \"polygon\", \"polygon\"… #> $ bias_area                   <list> [<sf[1 x 1]>], [<sf[1 x 1]>], [<sf[1 x 1]… #> $ bias_strength               <dbl> 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.… #> $ coords_uncertainty_meters   <dbl> 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25… #> $ grid                        <list> [<sf[400 x 1]>], [<sf[400 x 1]>], [<sf[40… #> $ seed                        <dbl> 123, 123, 123, 123, 123, 123, 123, 123, 12… #> $ occurrences                 <list> [<sf[304 x 3]>], [<sf[304 x 3]>], [<sf[30… #> $ observations_total          <list> [<sf[304 x 6]>], [<sf[304 x 6]>], [<sf[30… #> $ observations                <list> [<sf[191 x 7]>], [<sf[191 x 7]>], [<sf[19… #> $ time_point                  <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … #> $ cell_code                   <chr> \"109\", \"113\", \"117\", \"126\", \"130\", \"133\", … #> $ n                           <int> 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, … #> $ min_coord_uncertainty       <dbl> 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25… #> $ geometry                    <POLYGON> POLYGON ((450.0069 300.0004..., POLYGO… # Create dataframe with custom column names multi_species_dataset2_renamed <- multi_species_dataset2 %>%   rename(\"polygon\" = \"species_range\",          \"det_prob\" = \"detection_probability\",          \"raster\" = \"grid\") # Create named list for argument conversion arg_conv_list <- list(   species_range = \"polygon\",   detection_probability = \"det_prob\",   grid = \"raster\" )  arg_conv_list #> $species_range #> [1] \"polygon\" #>  #> $detection_probability #> [1] \"det_prob\" #>  #> $grid #> [1] \"raster\" map_occ_cube_df3 <- multi_species_dataset2_renamed %>%   map_simulate_occurrences(arg_list = arg_conv_list) %>%   map_sample_observations(arg_list = arg_conv_list) %>%   map_filter_observations() %>% # Argument names match   map_add_coordinate_uncertainty() %>% # Argument names match   map_grid_designation(arg_list = arg_conv_list) #> [1] [using unconditional Gaussian simulation] #> [2] [using unconditional Gaussian simulation] #> [3] [using unconditional Gaussian simulation] #> [4] [using unconditional Gaussian simulation] #> [5] [using unconditional Gaussian simulation] #> [6] [using unconditional Gaussian simulation]  # How does the dataset look like? glimpse(map_occ_cube_df3) #> Rows: 6 #> Columns: 25 #> $ species                     <chr> \"species1\", \"species2\", \"species3\", \"speci… #> $ species_key                 <int> 1, 2, 3, 4, 5, 6 #> $ genus                       <chr> \"genus3\", \"genus3\", \"genus3\", \"genus2\", \"g… #> $ family                      <chr> \"family1\", \"family1\", \"family1\", \"family2\"… #> $ order                       <chr> \"order1\", \"order1\", \"order1\", \"order1\", \"o… #> $ class                       <chr> \"class1\", \"class1\", \"class1\", \"class1\", \"c… #> $ phylum                      <chr> \"phylum1\", \"phylum1\", \"phylum1\", \"phylum1\"… #> $ kingdom                     <chr> \"kingdom1\", \"kingdom1\", \"kingdom1\", \"kingd… #> $ polygon                     <list> [POLYGON ((500 200, 1000 100...], [POLYGON… #> $ initial_average_occurrences <dbl> 50, 100, 500, 50, 100, 500 #> $ n_time_points               <dbl> 6, 6, 6, 6, 6, 6 #> $ temporal_function           <list> function (initial_average_occurrences = 5… #> $ sd_step                     <dbl> 1, 1, NA, NA, NA, NA #> $ spatial_pattern             <chr> \"random\", \"random\", \"random\", \"clustered\",… #> $ det_prob                    <dbl> 0.8, 0.9, 1.0, 0.8, 0.9, 1.0 #> $ sampling_bias               <chr> \"polygon\", \"polygon\", \"polygon\", \"no_bias\"… #> $ bias_area                   <list> [<sf[1 x 1]>], [<sf[1 x 1]>], [<sf[1 x 1]… #> $ bias_strength               <dbl> 0.1, 0.2, 0.3, 1.0, 1.0, 1.0 #> $ coords_uncertainty_meters   <dbl> 25, 30, 50, 25, 30, 50 #> $ raster                      <list> [<sf[400 x 1]>], [<sf[400 x 1]>], [<sf[400… #> $ seed                        <dbl> 123, 123, 123, 123, 123, 123 #> $ occurrences                 <list> [<sf[304 x 3]>], [<sf[607 x 3]>], [<sf[302… #> $ observations_total          <list> [<sf[304 x 6]>], [<sf[607 x 6]>], [<sf[302… #> $ observations                <list> [<sf[191 x 7]>], [<sf[396 x 7]>], [<sf[210… #> $ occurrence_cube_df          <list> [<sf[2400 x 5]>], [<sf[2400 x 5]>], [<sf[…"},{"path":"https://b-cubed-eu.github.io/gcube/articles/multi-species-approach.html","id":"visualise-examples","dir":"Articles","previous_headings":"","what":"Visualise examples","title":"4. Creating cubes for multiple species","text":"Let’s visualise output two six species. Species 1 low initial number occurrences random walk time simulated using random spatial pattern. detection probability 0.8 undersampled road. confirm visualising spatial distribution occurrences sampling status.  species 6. Species 6 high initial number occurrences trend time simulated using clustered spatial pattern. detection probability 1 sampling bias.","code":"# Simulate detection process and unnest detections_df_raw <- map_sample_observations(df = map_sim_occ_df,                                              nested = FALSE) # Select species 1 and create sf object detections_df_raw1 <- detections_df_raw %>%   filter(species == \"species1\") %>%   st_sf() ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = detections_df_raw1,           aes(colour = observed)) +   scale_colour_manual(values = c(\"blue\", \"red\")) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of occurrences for each time point\") +   theme_minimal() # Select species 6 and create sf object detections_df_raw6 <- detections_df_raw %>%   filter(species == \"species6\") %>%   st_sf()  ggplot() +   geom_sf(data = polygon, fill = \"lightgreen\") +   geom_sf(data = road_polygon) +   geom_sf(data = detections_df_raw6,           aes(colour = observed)) +   scale_colour_manual(values = c(\"blue\", \"red\")) +   facet_wrap(~time_point, nrow = 2) +   labs(title = \"Distribution of occurrences for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/occurrence-process.html","id":"input","dir":"Articles","previous_headings":"","what":"Input","title":"1. Simulating the occurrence process","text":"functions set single polygon input enough go workflow using default arguments. user can change arguments allow flexibility. tutorial demonstrate different options. input, create polygon want simulate occurrences. represents spatial extend species. polygon looks like .","code":"polygon <- st_polygon(list(cbind(c(500, 1000, 1000, 600, 200, 100, 500),                                  c(200, 100, 700, 1000, 900, 500, 200)))) ggplot() +   geom_sf(data = polygon) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/occurrence-process.html","id":"simulate-occurrences","dir":"Articles","previous_headings":"","what":"Simulate occurrences","title":"1. Simulating the occurrence process","text":"generate occurrence points within polygon using simulate_occurrences() function. Default arguments ensure sf object POLYGON geometry sufficient simulate occurrences. options user defined arguments demonstrated next subsections.","code":"?simulate_occurrences"},{"path":"https://b-cubed-eu.github.io/gcube/articles/occurrence-process.html","id":"changing-number-of-occurrences-over-time","dir":"Articles","previous_headings":"Simulate occurrences","what":"Changing number of occurrences over time","title":"1. Simulating the occurrence process","text":"Say want 100 occurrences plot 10 years. can change trend average number occurrences time. visualise supporting functions used simulate_occurrences(). number occurrences always drawn Poisson distribution. Option 1 specify temporal function, draw Poisson distribution time point average (lambda parameter) initial_average_occurrences. plot simulated number occurrences time. see average close 100 time expected. Using different seed result different numbers average (close ) 100 time.  Option 2 can specify function , e.g. internal function simulate_random_walk() random walk time. random walk mathematical concept step determined randomly. sd_step parameter refers standard deviation random steps (drawn Normal distribution). higher value leading larger steps potentially greater variability path random walk. plot simulated number occurrences time follow random walk. Using different seed result different random pattern.  Option 3 can specify function determines average trend number occurrences time. provide example linear trend. try linear trend slope equal 1. plot simulated number occurrences time. see average slope indeed close 1. Using different seed result different numbers average slope (close ) 1.","code":"?simulate_timeseries n_occurrences_indep <- simulate_timeseries(   initial_average_occurrences = 100,   n_time_points = 10,   temporal_function = NA,   seed = 123 ) tibble(   n_occurrences = n_occurrences_indep,   time_point = seq_along(n_occurrences_indep) ) %>%   ggplot(aes(x = time_point, y = n_occurrences)) +   geom_point() +   geom_smooth(method = \"lm\", formula = \"y ~ x\", se = FALSE) +   theme_minimal() n_occurrences_walk <- simulate_timeseries(   initial_average_occurrences = 100,   n_time_points = 10,   temporal_function = simulate_random_walk,   sd_step = 1,   seed = 123 ) tibble(   n_occurrences = n_occurrences_walk,   time_point = seq_along(n_occurrences_walk) ) %>%   ggplot(aes(x = time_point, y = n_occurrences)) +   geom_point() +   theme_minimal() my_own_linear_function <- function(     initial_average_occurrences = initial_average_occurrences,     n_time_points = n_time_points,     coef) {   # Calculate new average abundances over time   time <- seq_len(n_time_points) - 1   lambdas <- initial_average_occurrences + (coef * time)    # Identify where the lambda values become 0 or lower   zero_or_lower_index <- which(lambdas <= 0)    # If any lambda becomes 0 or lower, set all subsequent lambdas to 0   if (length(zero_or_lower_index) > 0) {     zero_or_lower_indices <- zero_or_lower_index[1]:n_time_points     lambdas[zero_or_lower_indices] <- 0   }    # Return average abundances   return(lambdas) } n_occurrences_linear <- simulate_timeseries(   initial_average_occurrences = 100,   n_time_points = 10,   temporal_function = my_own_linear_function,   coef = 1,   seed = 123 ) tibble(   n_occurrences = n_occurrences_linear,   time_point = seq_along(n_occurrences_linear) ) %>%   ggplot(aes(x = time_point, y = n_occurrences)) +   geom_point() +   geom_smooth(method = \"lm\", formula = \"y ~ x\", se = FALSE) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/occurrence-process.html","id":"changing-the-degree-of-spatial-clustering","dir":"Articles","previous_headings":"Simulate occurrences","what":"Changing the degree of spatial clustering","title":"1. Simulating the occurrence process","text":"can also choose amount spatial clustering. visualise supporting functions used simulate_occurrences(). Option 1 defaults random clustered patterns. Let’s look default clustering. see values high sampling probability randomly distributed.  Option 2 Let’s look default clustering (spatial_pattern = 10, see ). see values high sampling probability clustered together.  Option 3 can also change clustering . larger number spatial_pattern means broader size clusters area. Let’s look low value clustering. see values high sampling probability multiple, smaller clusters.  Let’s look high value clustering. see values high sampling probability fewer, larger clusters.  patterns generated used sampling using different supporting function. example sample 500 occurrences last raster, see sampling according expected pattern.","code":"?create_spatial_pattern rs_pattern_random <- create_spatial_pattern(   polygon = polygon,   resolution = 10,   spatial_pattern = \"random\",   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_spatraster(data = rs_pattern_random) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal() rs_pattern_clustered <- create_spatial_pattern(   polygon = polygon,   resolution = 10,   spatial_pattern = \"clustered\",   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_spatraster(data = rs_pattern_clustered) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal() rs_pattern_clustered2 <- create_spatial_pattern(   polygon = polygon,   resolution = 10,   spatial_pattern = 5,   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_spatraster(data = rs_pattern_clustered2) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal() rs_pattern_clustered3 <- create_spatial_pattern(   polygon = polygon,   resolution = 10,   spatial_pattern = 100,   seed = 123 ) #> [using unconditional Gaussian simulation] ggplot() +   geom_spatraster(data = rs_pattern_clustered3) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal() ?sample_occurrences_from_raster pts_occ_clustered3 <- sample_occurrences_from_raster(   raster = rs_pattern_clustered3,   time_series = 500,   seed = 123 )  ggplot() +   geom_spatraster(data = rs_pattern_clustered3) +   geom_sf(data = pts_occ_clustered3) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/articles/occurrence-process.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"1. Simulating the occurrence process","text":"Now know supporting functions work, can generate occurrence points within polygon using simulate_occurrences() function. can example sample randomly within polygon 6 time points use random walk time initial average number occurrences equal 100. number occurrences time point.  spatial distribution occurrences time point.","code":"occurrences_df <- simulate_occurrences(   species_range = polygon,   initial_average_occurrences = 100,   n_time_points = 6,   temporal_function = simulate_random_walk,   sd_step = 1,   spatial_pattern = \"random\",   seed = 123 ) #> [using unconditional Gaussian simulation] occurrences_df %>%   st_drop_geometry() %>%   count(time_point) %>%   ggplot(aes(x =  time_point, y = n)) +   geom_point() +   theme_minimal() ggplot() +   geom_sf(data = polygon) +   geom_sf(data = occurrences_df) +   facet_wrap(~time_point, nrow = 2) +   ggtitle(\"Distribution of occurrences for each time point\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ward Langeraert. Author, maintainer.            Research Institute Nature Forest (INBO) Wissam Barhdadi. Contributor. Dimitri Brosens. Contributor. Rocìo Cortès. Contributor. Peter Desmet. Contributor. Michele Di Musciano. Contributor. Chandra Earl. Contributor. Sanne Govaert. Contributor. Pieter Huybrechts. Contributor. Matilde Martini. Contributor. Arthur Rodrigues. Contributor. Toon Van Daele. Contributor. Annegreet Veeken. Contributor. Mukhtar Muhammed Yahaya. Contributor. Research Institute Nature Forest (INBO). Copyright holder. European Union. Funder.           https://doi.org/10.3030/101059592","code":""},{"path":"https://b-cubed-eu.github.io/gcube/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Langeraert, Ward (2025) gcube: Simulating Biodiversity Data Cubes. Version 1.3.7. https://b-cubed-eu.github.io/gcube/","code":"@Manual{,   title = {gcube: Simulating Biodiversity Data Cubes. Version 1.3.7},   author = {Ward Langeraert},   year = {2025},   url = {https://b-cubed-eu.github.io/gcube/},   abstract = {This R package provides a simulation framework for biodiversity data cubes. This can start from simulating multiple species distributed in a landscape over a temporal scope. In a second phase, the simulation of a variety of observation processes and effort can generate actual occurrence datasets. Based on their (simulated) spatial uncertainty, occurrences can then be designated to a grid to form a data cube.},   keywords = {simulation; data cubes; B-Cubed; biodiversity; Monte-Carlo},   doi = {10.5281/zenodo.14038996}, }"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"gcube-","dir":"","previous_headings":"","what":"Simulating Biodiversity Data Cubes","title":"Simulating Biodiversity Data Cubes","text":"goal gcube provide simulation framework biodiversity data cubes using R programming language. can start simulating multiple species distributed landscape temporal scope. second phase, simulation variety observation processes effort can generate actual occurrence datasets. Based (simulated) spatial uncertainty, occurrences can designated grid form data cube. Simulation studies offer numerous benefits due ability mimic real-world scenarios controlled customizable environments. Ecosystems biodiversity data complex involve multitude interacting factors. Simulations allow researchers model understand complexity ecological systems varying parameters spatial /temporal clustering, species prevalence, etc.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulating Biodiversity Data Cubes","text":"Install gcube R: can install development version GitHub :","code":"install.packages(\"gcube\", repos = \"https://b-cubed-eu.r-universe.dev\") # install.packages(\"remotes\") remotes::install_github(\"b-cubed-eu/gcube\")"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"package-name-rationale-and-origin-story","dir":"","previous_headings":"","what":"Package name rationale and origin story","title":"Simulating Biodiversity Data Cubes","text":"name gcube stands “generate cube” since can used generate biodiversity data cubes minimal input. first developed hackathon “Hacking Biodiversity Data Cubes Policy”, won first price category “Visualization training”. can read full story : https://doi.org/10.37044/osf.io/vcyr7","code":""},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Simulating Biodiversity Data Cubes","text":"basic example shows workflow simulating biodiversity data cube. divided three steps processes: Occurrence process Detection process Grid designation process functions set single polygon input enough go workflow using default arguments. user can change arguments allow flexibility. create polygon input. represents spatial extend species.","code":"# Load packages library(gcube)  library(sf)      # working with spatial objects library(dplyr)   # data wrangling library(ggplot2) # visualisation with ggplot # Create a polygon to simulate occurrences within polygon <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7,9, 5, 2))))  # Visualise ggplot() +    geom_sf(data = polygon) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"occurrence-process","dir":"","previous_headings":"Example","what":"Occurrence process","title":"Simulating Biodiversity Data Cubes","text":"generate occurrence points within polygon using simulate_occurrences() function. function, user can specify different levels spatial clustering, define trend number occurrences time. default random spatial pattern single time point rpois(1, 50) occurrences.","code":"# Simulate occurrences within polygon occurrences_df <- simulate_occurrences(   species_range = polygon,   initial_average_occurrences = 50,   spatial_pattern = c(\"random\", \"clustered\"),   n_time_points = 1,   seed = 123) #> [using unconditional Gaussian simulation]  # Visualise ggplot() +    geom_sf(data = polygon) +   geom_sf(data = occurrences_df) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"detection-process","dir":"","previous_headings":"Example","what":"Detection process","title":"Simulating Biodiversity Data Cubes","text":"second step define sampling process, based detection probability species sampling bias. done using sample_observations() function. default sampling bias \"no_bias\", bias can added using polygon grid well.  select detected occurrences add uncertainty observations. can done using filter_observations() add_coordinate_uncertainty() functions, respectively.","code":"# Detect occurrences detections_df_raw <- sample_observations(   occurrences = occurrences_df,   detection_probability = 0.5,   sampling_bias = c(\"no_bias\", \"polygon\", \"manual\"),   seed = 123)  # Visualise ggplot() +    geom_sf(data = polygon) +   geom_sf(data = detections_df_raw,           aes(colour = observed)) +   theme_minimal() # Select detected occurrences only detections_df <- filter_observations(   observations_total = detections_df_raw)  # Add coordinate uncertainty set.seed(123) coord_uncertainty_vec <- rgamma(nrow(detections_df), shape = 2, rate = 6) observations_df <- add_coordinate_uncertainty(   observations = detections_df,   coords_uncertainty_meters = coord_uncertainty_vec)  # Created and sf object with uncertainty circles to visualise buffered_observations <- st_buffer(   observations_df,   observations_df$coordinateUncertaintyInMeters)  # Visualise ggplot() +    geom_sf(data = polygon) +   geom_sf(data = buffered_observations,           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = observations_df, colour = \"firebrick\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"grid-designation-process","dir":"","previous_headings":"Example","what":"Grid designation process","title":"Simulating Biodiversity Data Cubes","text":"Finally, observations designated grid grid_designation() create occurrence cube. create grid spatial extend using sf::st_make_grid(). create occurrence cube, grid_designation() randomly take point within uncertainty circle around observations. points can extracted setting argument aggregate = FALSE.  output gives number observations per grid cell minimal coordinate uncertainty per grid cell.","code":"# Define a grid over spatial extend grid_df <- st_make_grid(     buffered_observations,     square = TRUE,     cellsize = c(1.2, 1.2)   ) %>%   st_sf() %>%   mutate(intersect = as.vector(st_intersects(geometry, polygon,                                              sparse = FALSE))) %>%   dplyr::filter(intersect == TRUE) %>%   dplyr::select(-\"intersect\") # Create occurrence cube occurrence_cube_df <- grid_designation(   observations = observations_df,   grid = grid_df,   seed = 123)  # Get sampled points within uncertainty circle sampled_points <- grid_designation(   observations = observations_df,   grid = grid_df,   aggregate = FALSE,   seed = 123)  # Visualise grid designation ggplot() +   geom_sf(data = occurrence_cube_df, linewidth = 1) +   geom_sf_text(data = occurrence_cube_df, aes(label = n)) +   geom_sf(data = buffered_observations,           fill = alpha(\"firebrick\", 0.3)) +   geom_sf(data = sampled_points, colour = \"blue\") +   geom_sf(data = observations_df, colour = \"firebrick\") +   labs(x = \"\", y = \"\", fill = \"n\") +   theme_minimal() # Visualise minimal coordinate uncertainty ggplot() +   geom_sf(data = occurrence_cube_df, aes(fill = min_coord_uncertainty),           alpha = 0.5, linewidth = 1) +   geom_sf_text(data = occurrence_cube_df, aes(label = n)) +   scale_fill_continuous(type = \"viridis\") +   labs(x = \"\", y = \"\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/index.html","id":"cubes-for-multiple-species","dir":"","previous_headings":"Example","what":"Cubes for multiple species","title":"Simulating Biodiversity Data Cubes","text":"cube simulation function mentioned earlier corresponding mapping function. mapping functions designed handle operations multiple species simultaneously using purrr::pmap() function. Please consult documentation detailed information mapping functions implemented.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/add_coordinate_uncertainty.html","id":null,"dir":"Reference","previous_headings":"","what":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","title":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","text":"function adds column input dataframe sf object containing coordinate uncertainty observation, measured meters.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/add_coordinate_uncertainty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","text":"","code":"add_coordinate_uncertainty(observations, coords_uncertainty_meters = 25)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/add_coordinate_uncertainty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","text":"observations sf object POINT geometry simple dataframe representing observations. object contains observation points coordinate uncertainty added. coords_uncertainty_meters numeric value vector numeric values representing coordinate uncertainty (meters) associated observation. single numeric value provided, applied observations. numeric vector provided, must length number observations.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/add_coordinate_uncertainty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","text":"input data frame sf object POINT geometry, additional column named coordinateUncertaintyInMeters contains coordinate uncertainty values meters.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/add_coordinate_uncertainty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add coordinate uncertainty to observations — add_coordinate_uncertainty","text":"","code":"# Create dataframe with sampling status column observations_data <- data.frame(     time_point = 1,     sampling_prob = seq(0.5, 1, 0.1)   )  # provide a fixed uncertainty for all points add_coordinate_uncertainty(   observations_data,   coords_uncertainty_meters = 1000  ) #>   time_point sampling_prob coordinateUncertaintyInMeters #> 1          1           0.5                          1000 #> 2          1           0.6                          1000 #> 3          1           0.7                          1000 #> 4          1           0.8                          1000 #> 5          1           0.9                          1000 #> 6          1           1.0                          1000  # add variability in uncertainty. For example, using gamma distribution uncertainty_vec <- seq(50, 100, 10)  add_coordinate_uncertainty(   observations_data,   coords_uncertainty_meters = uncertainty_vec ) #>   time_point sampling_prob coordinateUncertaintyInMeters #> 1          1           0.5                            50 #> 2          1           0.6                            60 #> 3          1           0.7                            70 #> 4          1           0.8                            80 #> 5          1           0.9                            90 #> 6          1           1.0                           100"},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_manual_sampling_bias.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","title":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","text":"function adds sampling bias weight column sf object containing occurrences. sampling probabilities based bias weights within cell provided grid layer.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_manual_sampling_bias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","text":"","code":"apply_manual_sampling_bias(occurrences_sf, bias_weights)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_manual_sampling_bias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","text":"occurrences_sf sf object POINT geometry representing occurrences. bias_weights sf object POLYGON geometry representing grid bias weights. sf object contain bias_weight column geometry column. Higher weights indicate higher probability sampling. Weights must numeric values 0 1 positive integers, rescaled values 0 1.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_manual_sampling_bias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","text":"sf object POINT geometry includes bias_weight column containing sampling probabilities based sampling bias.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_manual_sampling_bias.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply manual sampling bias to occurrences via a grid — apply_manual_sampling_bias","text":"","code":"# Load packages library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(ggplot2)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  # Get occurrence points occurrences_sf <- simulate_occurrences(plgn) #> [using unconditional Gaussian simulation]  # Create grid with bias weights grid <- st_make_grid(     plgn,     n = c(10, 10),     square = TRUE) %>%   st_sf() grid$bias_weight <- runif(nrow(grid), min = 0, max = 1)  # Calculate occurrence bias occurrence_bias <- apply_manual_sampling_bias(occurrences_sf, grid) occurrence_bias #> Simple feature collection with 40 features and 3 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 2.805565 ymin: 1.46267 xmax: 8.254267 ymax: 8.551619 #> CRS:           NA #> First 10 features: #>    time_point sampling_p1 bias_weight                  geometry #> 40          1   0.9214596  0.23581957  POINT (7.10732 1.658796) #> 5           1   0.9993232  0.13919488   POINT (7.90152 1.46267) #> 13          1   0.9979411  0.04815941 POINT (6.158066 1.950062) #> 31          1   0.9950043  0.04815941 POINT (6.102045 2.024401) #> 25          1   0.9998381  0.68258195 POINT (7.045201 1.830053) #> 4           1   0.9782428  0.62286399 POINT (7.956353 1.897629) #> 14          1   0.6684262  0.55225256 POINT (4.923372 3.282674) #> 27          1   0.9999701  0.55225256 POINT (4.751308 2.751113) #> 28          1   0.9987659  0.55225256  POINT (4.98449 2.713699) #> 23          1   0.9926203  0.77067736 POINT (5.477754 3.061427)  # Visualise where the bias is ggplot() +   geom_sf(data = plgn) +   geom_sf(data = grid, alpha = 0) +   geom_sf(data = occurrence_bias, aes(colour = bias_weight)) +   geom_sf_text(data = grid, aes(label = round(bias_weight, 2))) +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_polygon_sampling_bias.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","title":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","text":"function adds sampling bias weight column sf object containing occurrences based given polygonal area. bias determined specified bias strength, adjusts probability sampling within polygonal area.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_polygon_sampling_bias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","text":"","code":"apply_polygon_sampling_bias(occurrences_sf, bias_area, bias_strength = 1)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_polygon_sampling_bias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","text":"occurrences_sf sf object POINT geometry representing occurrences. bias_area sf object POLYGON geometry specifying area sampling biased. bias_strength positive numeric value represents strength bias applied within bias_area. Values greater 1 increase sampling probability within polygon relative outside (oversampling), values 0 1 decrease (undersampling). instance, value 50 make probability 50 times higher within bias_area compared outside, whereas value 0.5 make half likely.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_polygon_sampling_bias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","text":"sf object POINT geometry includes bias_weight column containing sampling probabilities based bias area strength.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/apply_polygon_sampling_bias.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply sampling bias to occurrences via a polygon — apply_polygon_sampling_bias","text":"","code":"# Load packages library(sf) library(dplyr) library(ggplot2)  # Simulate some occurrence data with coordinates and time points num_points <- 10 occurrences <- data.frame(   lon = runif(num_points, min = -180, max = 180),   lat = runif(num_points, min = -90, max = 90),   time_point = 1   )  # Convert the occurrence data to an sf object occurrences_sf <- st_as_sf(occurrences, coords = c(\"lon\", \"lat\"))  # Create bias_area polygon overlapping at least two of the points selected_observations <- st_union(occurrences_sf[2:3,]) bias_area <- st_convex_hull(selected_observations) %>%   st_buffer(dist = 50) %>%   st_as_sf()  occurrence_bias_sf <- apply_polygon_sampling_bias(   occurrences_sf,   bias_area,   bias_strength = 2) occurrence_bias_sf #> Simple feature collection with 10 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -136.2232 ymin: -78.63914 xmax: 125.5279 ymax: 69.20006 #> CRS:           NA #>    time_point                    geometry bias_weight #> 1           1   POINT (109.4206 69.20006)   0.6666667 #> 2           1 POINT (-136.2232 -38.33177)   0.6666667 #> 3           1   POINT (125.5279 40.48306)   0.6666667 #> 4           1 POINT (-124.9616 -2.428915)   0.6666667 #> 5           1 POINT (-110.0708 -78.63914)   0.6666667 #> 6           1   POINT (36.78761 60.29309)   0.6666667 #> 7           1  POINT (-55.41635 24.22807)   0.6666667 #> 8           1  POINT (99.90885 -44.94458)   0.3333333 #> 9           1 POINT (-100.5421 -66.89182)   0.6666667 #> 10          1  POINT (-116.9119 14.24529)   0.6666667  # Visualise where the bias is occurrence_bias_sf %>%   mutate(bias_weight = as.factor(round(bias_weight, 3))) %>%   ggplot() +     geom_sf(data = bias_area) +     geom_sf(aes(colour = bias_weight)) +     theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial pattern within a polygon — create_spatial_pattern","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"function creates raster spatial pattern area polygon.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"","code":"create_spatial_pattern(   polygon,   resolution,   spatial_pattern = c(\"random\", \"clustered\"),   seed = NA,   n_sim = 1 )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"polygon sf object POLYGON geometry. resolution numeric value defining resolution raster cells. spatial_pattern Specifies desired spatial pattern. can character string (\"random\" \"clustered\") numeric value ≥ 1 (1 means random distribution, larger values indicate clustering). default \"random\". \"clustered\" corresponds value 10. See Details. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function. n_sim Number simulations. simulation different layer raster. Default 1.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"object class SpatRaster spatial pattern area given polygon n_sim layers sampling_p'n_sim' containing sampling probabilities raster grid simulation.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"spatial_pattern argument changes range parameter spherical variogram model. spatial_pattern = 1 means range size grid cell, defined resolution argument. function gstat::vgm() used implement spherical variogram model.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/create_spatial_pattern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create spatial pattern within a polygon — create_spatial_pattern","text":"","code":"# Load packages library(sf) library(ggplot2) library(tidyterra) #>  #> Attaching package: ‘tidyterra’ #> The following object is masked from ‘package:stats’: #>  #>     filter  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  # 1. Random spatial pattern rs_pattern_random <- create_spatial_pattern(   polygon = plgn,   resolution = 0.1,   spatial_pattern = \"random\",   seed = 123) #> [using unconditional Gaussian simulation]  ggplot() +   geom_spatraster(data = rs_pattern_random) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()   # 2. Clustered spatial pattern rs_pattern_clustered <- create_spatial_pattern(   polygon = plgn,   resolution = 0.1,   spatial_pattern = \"clustered\",   seed = 123) #> [using unconditional Gaussian simulation]  ggplot() +   geom_spatraster(data = rs_pattern_clustered) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()   # 3. User defined spatial pattern # Large scale clustering rs_pattern_large <- create_spatial_pattern(   polygon = plgn,   resolution = 0.1,   spatial_pattern = 100,   seed = 123) #> [using unconditional Gaussian simulation]  ggplot() +   geom_spatraster(data = rs_pattern_large) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/reference/filter_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter detected occurrences — filter_observations","title":"Filter detected occurrences — filter_observations","text":"function filters observations occurrences based observed column, typically created sample_observations() function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/filter_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter detected occurrences — filter_observations","text":"","code":"filter_observations(observations_total, invert = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/filter_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter detected occurrences — filter_observations","text":"observations_total sf object POINT geometry simple dataframe observed column containing logical values (TRUE/FALSE). format typically created sample_observations() function. invert Logical. FALSE (default), function filters retain observed occurrences. TRUE, filters unobserved occurrences.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/filter_observations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter detected occurrences — filter_observations","text":"data frame sf object POINT geometry containing filtered observations. invert = FALSE, function returns observed occurrences. invert = TRUE, returns unobserved occurrences.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/filter_observations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter detected occurrences — filter_observations","text":"","code":"# Create dataframe with sampling status column occurrences_data <- data.frame(     time_point = 1,     sampling_prob = seq(0.5, 1, 0.1),     observed = rep(c(FALSE, TRUE), each = 3)   )  # Keep detected occurrences filter_observations(occurrences_data) #>   time_point sampling_prob observed #> 4          1           0.8     TRUE #> 5          1           0.9     TRUE #> 6          1           1.0     TRUE  # Keep undetected occurrences filter_observations(occurrences_data, invert = TRUE) #>   time_point sampling_prob observed #> 1          1           0.5    FALSE #> 2          1           0.6    FALSE #> 3          1           0.7    FALSE"},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a taxonomic hierarchy — generate_taxonomy","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"function generates random taxonomic hierarchy specified numbers species, genera, families, orders, classes, phyla, kingdoms. output data frame hierarchical classification species.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"","code":"generate_taxonomy(   num_species,   num_genera,   num_families,   num_orders = 1,   num_classes = 1,   num_phyla = 1,   num_kingdoms = 1,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"num_species Number species generate, dataframe. dataframe, function create species taxonomic hierarchy row. original columns dataframe retained output. num_genera Number genera generate. num_families Number families generate. num_orders Number orders generate. Defaults 1. num_classes Number classes generate. Defaults 1. num_phyla Number phyla generate. Defaults 1. num_kingdoms Number kingdoms generate. Defaults 1. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"data frame taxonomic classification species. num_species dataframe, taxonomic classification added input dataframe. original columns dataframe retained output.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"function works randomly assigning species genera, genera families, families orders, orders classes, classes phyla, phyla kingdoms. Sampling done replacement, allowing multiple lower-level taxa (e.g., species) assigned higher-level taxon (e.g., genus).","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/generate_taxonomy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a taxonomic hierarchy — generate_taxonomy","text":"","code":"# 1. Create simple taxonomic hierarchy generate_taxonomy(   num_species = 5,   num_genera = 3,   num_families = 2,   seed = 123) #>    species species_key  genus  family  order  class  phylum  kingdom #> 1 species1           1 genus3 family2 order1 class1 phylum1 kingdom1 #> 2 species2           2 genus3 family2 order1 class1 phylum1 kingdom1 #> 3 species3           3 genus3 family2 order1 class1 phylum1 kingdom1 #> 4 species4           4 genus2 family2 order1 class1 phylum1 kingdom1 #> 5 species5           5 genus3 family2 order1 class1 phylum1 kingdom1  # 2. Add taxonomic hierarchy to a dataframe existing_df <- data.frame(   count = c(1, 2, 5, 4, 8, 9, 3),   det_prob = c(0.9, 0.9, 0.9, 0.8, 0.5, 0.2, 0.2)   )  generate_taxonomy(   num_species = existing_df,   num_genera = 4,   num_families = 2,   seed = 125) #>    species species_key  genus  family  order  class  phylum  kingdom count #> 1 species1           1 genus2 family1 order1 class1 phylum1 kingdom1     1 #> 2 species2           2 genus2 family1 order1 class1 phylum1 kingdom1     2 #> 3 species3           3 genus3 family2 order1 class1 phylum1 kingdom1     5 #> 4 species4           4 genus4 family2 order1 class1 phylum1 kingdom1     4 #> 5 species5           5 genus4 family2 order1 class1 phylum1 kingdom1     8 #> 6 species6           6 genus3 family2 order1 class1 phylum1 kingdom1     9 #> 7 species7           7 genus1 family1 order1 class1 phylum1 kingdom1     3 #>   det_prob #> 1      0.9 #> 2      0.9 #> 3      0.9 #> 4      0.8 #> 5      0.5 #> 6      0.2 #> 7      0.2"},{"path":"https://b-cubed-eu.github.io/gcube/reference/grid_designation.html","id":null,"dir":"Reference","previous_headings":"","what":"Observations to grid designation to create a data cube — grid_designation","title":"Observations to grid designation to create a data cube — grid_designation","text":"function designates observations cells given grid create aggregated data cube.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/grid_designation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observations to grid designation to create a data cube — grid_designation","text":"","code":"grid_designation(   observations,   grid,   id_col = \"row_names\",   missing_uncertainty = 1000,   seed = NA,   aggregate = TRUE,   randomisation = c(\"uniform\", \"normal\"),   p_norm = ifelse(tolower(randomisation[1]) == \"uniform\", NA, 0.95) )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/grid_designation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observations to grid designation to create a data cube — grid_designation","text":"observations sf object POINT geometry time_point coordinateUncertaintyInMeters column. former column present, function assume single time point. latter column present, function assume uncertainty (zero meters) around observation points. grid sf object POLYGON geometry (usually grid) observations designated. id_col column name containing unique IDs grid cell. \"row_names\" (default), new column cell_code created row names represent unique IDs. missing_uncertainty positive numeric value (default: 1000 m) used replace missing (NA) values coordinateUncertaintyInMeters column. ensures observations defined uncertainty radius sampling. applied column present contains NA values; column absent, value 0 assumed instead. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function. aggregate Logical. TRUE (default), returns data cube aggregated form (grid number observations per grid cell). Otherwise, returns sampled points within uncertainty circle. randomisation Character. Method used sampling within uncertainty circle around observation. \"uniform\" (default) means point uncertainty circle equal probability selected. option \"normal\", point sampled bivariate Normal distribution means equal observation point variance p_norm % possible samples Normal distribution fall within uncertainty circle. See sample_from_binormal_circle(). p_norm numeric value 0 1, used randomisation = \"normal\". proportion possible samples bivariate Normal distribution fall within uncertainty circle. Default 0.95.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/grid_designation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observations to grid designation to create a data cube — grid_designation","text":"aggregate = TRUE, sf object POLYGON geometry containing grid cells, n column number observations per grid cell, min_coord_uncertainty column minimum coordinate uncertainty per grid cell. aggregate = FALSE, sf object POINT geometry containing sampled observations within uncertainty circles, coordinateUncertaintyInMeters column coordinate uncertainty observation.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/grid_designation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observations to grid designation to create a data cube — grid_designation","text":"","code":"library(sf) library(dplyr)  # Create four random points n_points <- 4 xlim <- c(3841000, 3842000) ylim <- c(3110000, 3112000) coordinate_uncertainty <- rgamma(n_points, shape = 5, rate = 0.1)  observations_sf <- data.frame(   lat = runif(n_points, ylim[1], ylim[2]),   long = runif(n_points, xlim[1], xlim[2]),   time_point = 1,   coordinateUncertaintyInMeters = coordinate_uncertainty ) %>%   st_as_sf(coords = c(\"long\", \"lat\"), crs = 3035)  # Add buffer uncertainty in meters around points observations_buffered <- observations_sf %>%   st_buffer(observations_sf$coordinateUncertaintyInMeters)  # Create grid grid_df <- st_make_grid(   observations_buffered,   square = TRUE,   cellsize = c(200, 200) ) %>%   st_sf()  # Create occurrence cube grid_designation(   observations = observations_sf,   grid = grid_df,   seed = 123 ) #> Simple feature collection with 40 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 3841029 ymin: 3110005 xmax: 3841829 ymax: 3112005 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 40 × 5 #>    time_point cell_code     n min_coord_uncertainty                     geometry #>  *      <dbl> <chr>     <int>                 <dbl>                <POLYGON [m]> #>  1          1 1             1                  59.9 ((3841029 3110005, 3841229 … #>  2          1 35            1                  83.1 ((3841429 3111605, 3841629 … #>  3          1 37            1                  26.1 ((3841029 3111805, 3841229 … #>  4          1 4             1                  38.5 ((3841629 3110005, 3841829 … #>  5          1 2             0                  NA   ((3841229 3110005, 3841429 … #>  6          1 3             0                  NA   ((3841429 3110005, 3841629 … #>  7          1 5             0                  NA   ((3841029 3110205, 3841229 … #>  8          1 6             0                  NA   ((3841229 3110205, 3841429 … #>  9          1 7             0                  NA   ((3841429 3110205, 3841629 … #> 10          1 8             0                  NA   ((3841629 3110205, 3841829 … #> # ℹ 30 more rows"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_add_coordinate_uncertainty.html","id":null,"dir":"Reference","previous_headings":"","what":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","title":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","text":"function executes add_coordinate_uncertainty() multiple rows dataframe, representing different species, potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_add_coordinate_uncertainty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","text":"","code":"map_add_coordinate_uncertainty(   df,   nested = TRUE,   arg_list = NA,   progress = FALSE )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_add_coordinate_uncertainty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","text":"df dataframe containing multiple rows, representing different species. columns function arguments values used mapping add_coordinate_uncertainty() species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing sf objects calculated add_coordinate_uncertainty(). Otherwise, expands list-column rows columns. arg_list named list NA. NA (default), function assumes column names df identical argument names add_coordinate_uncertainty(). column names differ, must specified named list names argument names add_coordinate_uncertainty(), associated values corresponding column names df. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_add_coordinate_uncertainty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","text":"case nested = TRUE, dataframe identical df, sf object POINT geometry list-column observations now additional column coordinateUncertaintyInMeters added add_coordinate_uncertainty(). case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_add_coordinate_uncertainty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map add_coordinate_uncertainty() over multiple species — map_add_coordinate_uncertainty","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 200),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   detection_probability = c(0.8, 0.9, 1),   invert = FALSE,   coords_uncertainty_meters = c(25, 30, 50),   seed = 123)  # Simulate occurrences sim_occ1 <- map_simulate_occurrences(df = species_dataset_df)  # Sample observations samp_obs1 <- map_sample_observations(df = sim_occ1)  # Filter observations filter_obs1 <- map_filter_observations(df = samp_obs1)  # Add coordinate uncertainty obs_uncertainty_nested <- map_add_coordinate_uncertainty(df = filter_obs1) obs_uncertainty_nested   ## Example with deviating column names # Specify dataframe for 3 species with custom function arguments species_dataset_df2 <- species_dataset_df %>%   rename(polygon = species_range,          sd = sd_step,          det_prob = detection_probability,          inv = invert,          coord_uncertainty = coords_uncertainty_meters)  # Create named list for argument conversion arg_conv_list <- list(     species_range = \"polygon\",     sd_step = \"sd\",     detection_probability = \"det_prob\",     invert = \"inv\",     coords_uncertainty_meters = \"coord_uncertainty\"   )  # Simulate occurrences sim_occ2 <- map_simulate_occurrences(   df = species_dataset_df2,   arg_list = arg_conv_list)  # Sample observations samp_obs2 <- map_sample_observations(   df = sim_occ2,   arg_list = arg_conv_list)  # Filter observations filter_obs2 <- map_filter_observations(   df = samp_obs2,   arg_list = arg_conv_list)  # Add coordinate uncertainty map_add_coordinate_uncertainty(   df = filter_obs2,   arg_list = arg_conv_list) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_filter_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Map filter_observations() over multiple species — map_filter_observations","title":"Map filter_observations() over multiple species — map_filter_observations","text":"function executes filter_observations() multiple rows dataframe, representing different species, potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_filter_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map filter_observations() over multiple species — map_filter_observations","text":"","code":"map_filter_observations(df, nested = TRUE, arg_list = NA, progress = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_filter_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map filter_observations() over multiple species — map_filter_observations","text":"df dataframe containing multiple rows, representing different species. columns function arguments values used mapping filter_observations() species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing sf objects/dataframes calculated filter_observations(). Otherwise, expands list-column rows columns. arg_list named list NA. NA (default), function assumes column names df identical argument names filter_observations(). column names differ, must specified named list names argument names filter_observations(), associated values corresponding column names df. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_filter_observations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map filter_observations() over multiple species — map_filter_observations","text":"case nested = TRUE, dataframe identical df, extra list-column called observations containing sf object POINT geometry simple dataframe row computed filter_observations(). case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_filter_observations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map filter_observations() over multiple species — map_filter_observations","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 200),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   detection_probability = c(0.8, 0.9, 1),   invert = FALSE,   seed = 123)  # Simulate occurrences sim_occ1 <- map_simulate_occurrences(df = species_dataset_df)  # Sample observations samp_obs1 <- map_sample_observations(df = sim_occ1)  # Filter observations filter_obs_nested <- map_filter_observations(df = samp_obs1) filter_obs_nested  ## Example with deviating column names # Specify dataframe for 3 species with custom function arguments species_dataset_df2 <- species_dataset_df %>%   rename(polygon = species_range,          sd = sd_step,          det_prob = detection_probability,          inv = invert)  # Create named list for argument conversion arg_conv_list <- list(     species_range = \"polygon\",     sd_step = \"sd\",     detection_probability = \"det_prob\",     invert = \"inv\"   )  # Simulate occurrences sim_occ2 <- map_simulate_occurrences(   df = species_dataset_df2,   arg_list = arg_conv_list)  # Sample observations samp_obs2 <- map_sample_observations(   df = sim_occ2,   arg_list = arg_conv_list)  # Filter observations map_filter_observations(   df = samp_obs2,   arg_list = arg_conv_list) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_grid_designation.html","id":null,"dir":"Reference","previous_headings":"","what":"Map grid_designation() over multiple species — map_grid_designation","title":"Map grid_designation() over multiple species — map_grid_designation","text":"function executes grid_designation() multiple rows dataframe, representing different species, potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_grid_designation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map grid_designation() over multiple species — map_grid_designation","text":"","code":"map_grid_designation(df, nested = TRUE, arg_list = NA, progress = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_grid_designation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map grid_designation() over multiple species — map_grid_designation","text":"df dataframe containing multiple rows, representing different species. columns function arguments values used mapping grid_designation() species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing sf objects calculated grid_designation(). Otherwise, expands list-column rows columns. arg_list named list NA. NA (default), function assumes column names df identical argument names grid_designation(). column names differ, must specified named list names argument names grid_designation(), associated values corresponding column names df. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_grid_designation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map grid_designation() over multiple species — map_grid_designation","text":"case nested = TRUE, dataframe identical df, sf object POINT geometry list-column observations now additional column coordinateUncertaintyInMeters added grid_designation(). case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_grid_designation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map grid_designation() over multiple species — map_grid_designation","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  # Create grid cube_grid <- st_make_grid(     st_buffer(plgn, 25),     n = c(20, 20),     square = TRUE) %>%   st_sf()  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 200),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   detection_probability = c(0.8, 0.9, 1),   invert = FALSE,   coords_uncertainty_meters = c(25, 30, 50),   grid = rep(list(cube_grid), 3),   seed = 123)  # Simulate occurrences sim_occ1 <- map_simulate_occurrences(df = species_dataset_df)  # Sample observations samp_obs1 <- map_sample_observations(df = sim_occ1)  # Filter observations filter_obs1 <- map_filter_observations(df = samp_obs1)  # Add coordinate uncertainty obs_uncertainty1 <- map_add_coordinate_uncertainty(df = filter_obs1)  # Grid designation occ_cube_nested <- map_grid_designation(df = obs_uncertainty1) occ_cube_nested  ## Example with deviating column names # Specify dataframe for 3 species with custom function arguments species_dataset_df2 <- species_dataset_df %>%   rename(polygon = species_range,          sd = sd_step,          det_prob = detection_probability,          inv = invert,          coord_uncertainty = coords_uncertainty_meters,          raster = grid)  # Create named list for argument conversion arg_conv_list <- list(     species_range = \"polygon\",     sd_step = \"sd\",     detection_probability = \"det_prob\",     invert = \"inv\",     coords_uncertainty_meters = \"coord_uncertainty\",     grid = \"raster\"   )  # Simulate occurrences sim_occ2 <- map_simulate_occurrences(   df = species_dataset_df2,   arg_list = arg_conv_list)  # Sample observations samp_obs2 <- map_sample_observations(   df = sim_occ2,   arg_list = arg_conv_list)  # Filter observations filter_obs2 <- map_filter_observations(   df = samp_obs2,   arg_list = arg_conv_list)  # Add coordinate uncertainty obs_uncertainty2 <- map_add_coordinate_uncertainty(   df = filter_obs2,   arg_list = arg_conv_list)  # Grid designation map_grid_designation(   df = obs_uncertainty2,   arg_list = arg_conv_list) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_sample_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Map sample_observations() over multiple species — map_sample_observations","title":"Map sample_observations() over multiple species — map_sample_observations","text":"function executes sample_observations() multiple rows dataframe, representing different species, potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_sample_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map sample_observations() over multiple species — map_sample_observations","text":"","code":"map_sample_observations(df, nested = TRUE, arg_list = NA, progress = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_sample_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map sample_observations() over multiple species — map_sample_observations","text":"df dataframe containing multiple rows, representing different species. columns function arguments values used mapping sample_observations() species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing sf objects calculated sample_observations(). Otherwise, expands list-column rows columns. arg_list named list NA. NA (default), function assumes column names df identical argument names sample_observations(). column names differ, must specified named list names argument names sample_observations(), associated values corresponding column names df. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_sample_observations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map sample_observations() over multiple species — map_sample_observations","text":"case nested = TRUE, dataframe identical df, extra list-column called occurrences containing sf object POINT geometry row computed sample_observations(). case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_sample_observations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map sample_observations() over multiple species — map_sample_observations","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 200),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   detection_probability = c(0.8, 0.9, 1),   seed = 123)  # Simulate occurrences sim_occ1 <- map_simulate_occurrences(df = species_dataset_df)  # Sample observations samp_obs_nested <- map_sample_observations(df = sim_occ1) samp_obs_nested  ## Example with deviating column names # Specify dataframe for 3 species with custom function arguments species_dataset_df2 <- species_dataset_df %>%   rename(polygon = species_range,          sd = sd_step,          det_prob = detection_probability)  # Create named list for argument conversion arg_conv_list <- list(     species_range = \"polygon\",     sd_step = \"sd\",     detection_probability = \"det_prob\"   )  # Simulate occurrences sim_occ2 <- map_simulate_occurrences(   df = species_dataset_df2,   arg_list = arg_conv_list)  # Sample observations map_sample_observations(   df = sim_occ2,   arg_list = arg_conv_list) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulate_occurrences.html","id":null,"dir":"Reference","previous_headings":"","what":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","title":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","text":"function executes simulate_occurrences() multiple rows dataframe, representing different species, potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulate_occurrences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","text":"","code":"map_simulate_occurrences(df, nested = TRUE, arg_list = NA, progress = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulate_occurrences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","text":"df dataframe containing multiple rows, representing different species. columns function arguments values used mapping simulate_occurrences() species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing sf objects calculated simulate_occurrences(). Otherwise, expands list-column rows columns. arg_list named list NA. NA (default), function assumes column names df identical argument names simulate_occurrences() function specified temporal_function argument. column names differ, must specified named list names argument names simulate_occurrences() function specified temporal_function argument, associated values corresponding column names df. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulate_occurrences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","text":"case nested = TRUE, dataframe identical df, extra list-column called occurrences containing sf object POINT geometry row computed simulate_occurrences(). case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulate_occurrences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map simulate_occurrences() over multiple species — map_simulate_occurrences","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 200),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   seed = 123)  # Simulate occurrences sim_occ_nested <- map_simulate_occurrences(df = species_dataset_df) sim_occ_nested  ## Example with deviating column names # Specify dataframe for 3 species with custom function arguments species_dataset_df2 <- species_dataset_df %>%   rename(polygon = species_range,          sd = sd_step)  # Create named list for argument conversion arg_conv_list <- list(     species_range = \"polygon\",     sd_step = \"sd\"   )  # Simulate occurrences map_simulate_occurrences(   df = species_dataset_df2,   arg_list = arg_conv_list) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulation_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","title":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","text":"function executes cube simulation function (simulate_occurrences(), sample_observations(), filter_observations(), add_coordinate_uncertainty(), grid_designation()) multiple rows dataframe potentially different function arguments multiple columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulation_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","text":"","code":"map_simulation_functions(f, df, nested = TRUE, progress = FALSE)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulation_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","text":"f One five cube simulation functions: simulate_occurrences(), sample_observations(), filter_observations(), add_coordinate_uncertainty(), grid_designation(). df dataframe containing multiple rows, representing different species. columns function arguments values used mapping f species. Columns used function retained output. nested Logical. TRUE (default), retains list-column containing dataframes calculated f. Otherwise, expands list-column rows columns. progress Logical. Whether show progress bar. Set TRUE display progress bar, FALSE (default) suppress .","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulation_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","text":"case nested = TRUE, dataframe identical df, extra list-column called mapped_col containing sf object row computed function specified f. case nested = FALSE, list-column expanded additional rows columns.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/map_simulation_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map a cube simulation function over multiple rows of a dataframe — map_simulation_functions","text":"","code":"if (FALSE) { # \\dontrun{ # Load packages library(sf) library(dplyr)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Example with simple column names # Specify dataframe for 3 species with custom function arguments species_dataset_df <- tibble(   taxonID = c(\"species1\", \"species2\", \"species3\"),   species_range = rep(list(plgn), 3),   initial_average_occurrences = c(50, 100, 500),   n_time_points = rep(6, 3),   temporal_function = c(simulate_random_walk, simulate_random_walk, NA),   sd_step = c(1, 1, NA),   spatial_pattern = \"random\",   seed = 123)  # Simulate occurrences sim_occ_raw <- map_simulation_functions(   f = simulate_occurrences,   df = species_dataset_df) sim_occ_raw  # Unnest output and create sf object sim_occ_raw_unnested <- map_simulation_functions(   f = simulate_occurrences,   df = species_dataset_df,   nested = FALSE)  sim_occ_raw_unnested %>%    st_sf() } # }"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"function samples new observations point species within uncertainty circle around observation assuming bivariate Normal distribution.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"","code":"sample_from_binormal_circle(   observations,   p_norm = 0.95,   missing_uncertainty = 1000,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"observations sf object POINT geometry time_point coordinateUncertaintyInMeters column. former column present, function assume single time point. latter column present, function assume uncertainty (zero meters) around observation points. p_norm numeric value 0 1. proportion possible samples bivariate Normal distribution fall within uncertainty circle. Default 0.95. See Details. missing_uncertainty positive numeric value (default: 1000 m) used replace missing (NA) values coordinateUncertaintyInMeters column. ensures observations defined uncertainty radius sampling. applied column present contains NA values; column absent, value 0 assumed instead. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"sf object POINT geometry containing locations sampled occurrences coordinateUncertaintyInMeters column containing coordinate uncertainty observation.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"new observation point sampled bivariate Normal distribution means equal X Y coordinates original observation point variances equal (-coordinateUncertaintyInMeters^2) / (2 * log(1 - p_norm)), ensuring p_norm % possible samples fall within uncertainty circle.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_binormal_circle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a circle using the bivariate Normal distribution — sample_from_binormal_circle","text":"","code":"library(sf) library(dplyr)  # Create four random points n_points <- 4 xlim <- c(3841000, 3842000) ylim <- c(3110000, 3112000) coordinate_uncertainty <- rgamma(n_points, shape = 5, rate = 0.1)  observations_sf <- data.frame(   lat = runif(n_points, ylim[1], ylim[2]),   long = runif(n_points, xlim[1], xlim[2]),   time_point = 1,   coordinateUncertaintyInMeters = coordinate_uncertainty ) %>%   st_as_sf(coords = c(\"long\", \"lat\"), crs = 3035)  # Sample points within uncertainty circles according to normal rules sample_from_binormal_circle(   observations = observations_sf,   p_norm = 0.95,   seed = 123 ) #> Simple feature collection with 4 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 3841171 ymin: 3109977 xmax: 3841969 ymax: 3110673 #> Projected CRS: ETRS89-extended / LAEA Europe #>   time_point coordinateUncertaintyInMeters                geometry #> 1          1                      39.28695 POINT (3841171 3110097) #> 2          1                      82.51448 POINT (3841969 3110402) #> 3          1                      68.26574 POINT (3841438 3110673) #> 4          1                      61.83829 POINT (3841758 3109977)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_uniform_circle.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","title":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","text":"function samples new observations point species within uncertainty circle around observation assuming Uniform distribution.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_uniform_circle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","text":"","code":"sample_from_uniform_circle(observations, missing_uncertainty = 1000, seed = NA)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_uniform_circle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","text":"observations sf object POINT geometry time_point coordinateUncertaintyInMeters column. former column present, function assume single time point. latter column present, function assume uncertainty (zero meters) around observation points. missing_uncertainty positive numeric value (default: 1000 m) used replace missing (NA) values coordinateUncertaintyInMeters column. ensures observations defined uncertainty radius sampling. applied column present contains NA values; column absent, value 0 assumed instead. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_uniform_circle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","text":"sf object POINT geometry containing locations sampled occurrences coordinateUncertaintyInMeters column containing coordinate uncertainty observation.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_from_uniform_circle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a circle using the Uniform distribution — sample_from_uniform_circle","text":"","code":"library(sf) library(dplyr)  # Create four random points n_points <- 4 xlim <- c(3841000, 3842000) ylim <- c(3110000, 3112000) coordinate_uncertainty <- rgamma(n_points, shape = 5, rate = 0.1)  observations_sf <- data.frame(   lat = runif(n_points, ylim[1], ylim[2]),   long = runif(n_points, xlim[1], xlim[2]),   time_point = 1,   coordinateUncertaintyInMeters = coordinate_uncertainty ) %>%   st_as_sf(coords = c(\"long\", \"lat\"), crs = 3035)  # Sample points within uncertainty circles according to uniform rules sample_from_uniform_circle(   observations = observations_sf,   seed = 123 ) #> Simple feature collection with 4 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 3841383 ymin: 3110074 xmax: 3841859 ymax: 3111938 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 4 × 3 #> # Rowwise:  #>   time_point coordinateUncertaintyInMeters          geometry #>        <dbl>                         <dbl>       <POINT [m]> #> 1          1                         25.0  (3841383 3110460) #> 2          1                        111.   (3841446 3111938) #> 3          1                          7.30 (3841606 3110807) #> 4          1                         37.7  (3841859 3110074)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample observations from a larger occurrence dataset — sample_observations","title":"Sample observations from a larger occurrence dataset — sample_observations","text":"function computes observations occurrences based detection probability sampling bias implementing Bernoulli trial.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample observations from a larger occurrence dataset — sample_observations","text":"","code":"sample_observations(   occurrences,   detection_probability = 1,   sampling_bias = c(\"no_bias\", \"polygon\", \"manual\"),   bias_area = NA,   bias_strength = 1,   bias_weights = NA,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample observations from a larger occurrence dataset — sample_observations","text":"occurrences sf object POINT geometry representing occurrences. detection_probability numeric value 0 1 representing probability detecting species. sampling_bias character string specifying method generate sampling bias. Options \"no_bias\", \"polygon\", \"manual\". \"no_bias\" bias applied (default). \"polygon\" Bias sampling within polygon. Provide polygon bias_area bias strength bias_strength. \"manual\" Bias sampling manually using grid. Provide grid layer cell contains probability sampled bias_weights. bias_area sf object POLYGON geometry, NA. used sampling_bias = \"polygon\". defines area sampling biased. bias_strength positive numeric value, NA. used sampling_bias = \"polygon\". value represents strength bias applied within bias_area. Values greater 1 increase sampling probability within polygon relative outside (oversampling), values 0 1 decrease (undersampling). instance, value 50 make probability 50 times higher within bias_area compared outside, whereas value 0.5 make half likely. bias_weights grid layer (sf object POLYGON geometry), NA. used sampling_bias = \"manual\". grid bias weights applied. sf object contain bias_weight column weights per grid cell. Higher weights increase probability sampling. Weights can numeric values 0 1 positive integers, rescaled values 0 1. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_observations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample observations from a larger occurrence dataset — sample_observations","text":"sf object POINT geometry containing locations occurrence detection status. object includes following columns: detection_probability detection probability occurrence (). bias_weight sampling probability based sampling bias occurrence. sampling_probability combined sampling probability detection probability sampling bias occurrence. observed Indicates whether occurrence detected (TRUE) (FALSE). Detected occurrences called observations.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_observations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample observations from a larger occurrence dataset — sample_observations","text":"","code":"# Load packages library(sf) library(dplyr)  # Simulate some occurrence data with coordinates and time points num_points <- 10 occurrences <- data.frame(   lon = runif(num_points, min = -180, max = 180),   lat = runif(num_points, min = -90, max = 90),   time_point = 0   )  # Convert the occurrence data to an sf object occurrences_sf <- st_as_sf(occurrences, coords = c(\"lon\", \"lat\"))  # 1. Sample observations without sampling bias sample_observations(   occurrences_sf,   detection_probability = 0.8,   sampling_bias = \"no_bias\",   seed = 123   ) #> Simple feature collection with 10 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -176.3391 ymin: -71.5952 xmax: 26.60207 ymax: 85.49863 #> CRS:           NA #> # A tibble: 10 × 6 #>    time_point detection_probability bias_weight sampling_probability observed #>         <dbl>                 <dbl>       <dbl>                <dbl> <lgl>    #>  1          0                   0.8           1                  0.8 TRUE     #>  2          0                   0.8           1                  0.8 TRUE     #>  3          0                   0.8           1                  0.8 TRUE     #>  4          0                   0.8           1                  0.8 FALSE    #>  5          0                   0.8           1                  0.8 FALSE    #>  6          0                   0.8           1                  0.8 TRUE     #>  7          0                   0.8           1                  0.8 TRUE     #>  8          0                   0.8           1                  0.8 FALSE    #>  9          0                   0.8           1                  0.8 TRUE     #> 10          0                   0.8           1                  0.8 TRUE     #> # ℹ 1 more variable: geometry <POINT>  # 2. Sample observations with sampling bias in a polygon # Create bias_area polygon overlapping two of the points selected_observations <- st_union(occurrences_sf[2:3,]) bias_area <- st_convex_hull(selected_observations) %>%   st_buffer(dist = 50) %>%   st_as_sf()  sample_observations(   occurrences_sf,   detection_probability = 0.8,   sampling_bias = \"polygon\",   bias_area = bias_area,   bias_strength = 2,   seed = 123   ) #> Simple feature collection with 10 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -176.3391 ymin: -71.5952 xmax: 26.60207 ymax: 85.49863 #> CRS:           NA #> # A tibble: 10 × 6 #>    time_point detection_probability bias_weight sampling_probability observed #>         <dbl>                 <dbl>       <dbl>                <dbl> <lgl>    #>  1          0                   0.8       0.333                0.267 FALSE    #>  2          0                   0.8       0.667                0.533 FALSE    #>  3          0                   0.8       0.667                0.533 TRUE     #>  4          0                   0.8       0.667                0.533 FALSE    #>  5          0                   0.8       0.333                0.267 TRUE     #>  6          0                   0.8       0.667                0.533 TRUE     #>  7          0                   0.8       0.333                0.267 FALSE    #>  8          0                   0.8       0.333                0.267 TRUE     #>  9          0                   0.8       0.333                0.267 FALSE    #> 10          0                   0.8       0.667                0.533 TRUE     #> # ℹ 1 more variable: geometry <POINT>  # 3. Sample observations with sampling bias given manually in a grid # Create raster grid with bias weights between 0 and 1 grid <- st_make_grid(occurrences_sf) %>%   st_sf() %>%   mutate(bias_weight = runif(n(), min = 0, max = 1))  sample_observations(   occurrences_sf,   detection_probability = 0.8,   sampling_bias = \"manual\",   bias_weights = grid,   seed = 123   ) #> Simple feature collection with 10 features and 5 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -176.3391 ymin: -71.5952 xmax: 26.60207 ymax: 85.49863 #> CRS:           NA #> # A tibble: 10 × 6 #>    time_point detection_probability bias_weight sampling_probability observed #>         <dbl>                 <dbl>       <dbl>                <dbl> <lgl>    #>  1          0                   0.8      0.895                0.716  TRUE     #>  2          0                   0.8      0.782                0.626  FALSE    #>  3          0                   0.8      0.929                0.743  TRUE     #>  4          0                   0.8      0.161                0.129  TRUE     #>  5          0                   0.8      0.835                0.668  FALSE    #>  6          0                   0.8      0.0860               0.0688 FALSE    #>  7          0                   0.8      0.755                0.604  TRUE     #>  8          0                   0.8      0.755                0.604  FALSE    #>  9          0                   0.8      0.279                0.223  FALSE    #> 10          0                   0.8      0.0781               0.0625 FALSE    #> # ℹ 1 more variable: geometry <POINT>"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_occurrences_from_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample occurrences from spatial random field — sample_occurrences_from_raster","title":"Sample occurrences from spatial random field — sample_occurrences_from_raster","text":"function draws point occurrences spatial random field represented raster. Points sampled based values raster, number occurrences specified time step.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_occurrences_from_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample occurrences from spatial random field — sample_occurrences_from_raster","text":"","code":"sample_occurrences_from_raster(raster, time_series, seed = NA)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_occurrences_from_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample occurrences from spatial random field — sample_occurrences_from_raster","text":"raster SpatRaster object (see terra::rast()). time_series vector number occurrences per time point. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_occurrences_from_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample occurrences from spatial random field — sample_occurrences_from_raster","text":"sf object POINT geometry containing locations simulated occurrences, time_point column indicating associated time point occurrence columns used weights sampling. raster created create_spatial_pattern(), column sampling_p1 used.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/sample_occurrences_from_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample occurrences from spatial random field — sample_occurrences_from_raster","text":"","code":"# Load packages library(sf) library(ggplot2) library(tidyterra)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  ## Medium scale clustering # Create the random field rs_pattern_clustered <- create_spatial_pattern(   polygon = plgn,   resolution = 0.1,   spatial_pattern = \"clustered\",   seed = 123) #> [using unconditional Gaussian simulation]  # Sample 200 occurrences from random field pts_occ_clustered <- sample_occurrences_from_raster(   raster = rs_pattern_clustered,   time_series = 200,   seed = 123)  ggplot() +   geom_spatraster(data = rs_pattern_clustered) +   geom_sf(data = pts_occ_clustered) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()   ## Large scale clustering # Create the random field rs_pattern_large <- create_spatial_pattern(   polygon = plgn,   resolution = 0.1,   spatial_pattern = 100,   seed = 123) #> [using unconditional Gaussian simulation]  # Sample 200 occurrences from random field pts_occ_large <- sample_occurrences_from_raster(   raster = rs_pattern_large,   time_series = 200,   seed = 123)  ggplot() +   geom_spatraster(data = rs_pattern_large) +   geom_sf(data = pts_occ_large) +   scale_fill_continuous(type = \"viridis\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_occurrences.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","title":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","text":"function simulates occurrences species within specified spatial /temporal extent.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_occurrences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","text":"","code":"simulate_occurrences(   species_range,   initial_average_occurrences = 50,   spatial_pattern = c(\"random\", \"clustered\"),   n_time_points = 1,   temporal_function = NA,   ...,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_occurrences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","text":"species_range sf object POLYGON geometry indicating spatial extend simulate occurrences. initial_average_occurrences positive numeric value indicating average number occurrences simulated within extent species_range first time point. value serves mean (lambda) Poisson distribution. spatial_pattern Specifies spatial pattern occurrences. can character string (\"random\" \"clustered\") numeric value ≥ 1 (1 means random distribution, larger values indicate clustering). default \"random\". \"clustered\" corresponds value 10. See create_spatial_pattern(). n_time_points positive integer specifying number time points simulate. temporal_function function generating trend number occurrences time, NA (default). n_time_points > 1 function provided, defines temporal pattern number occurrences. ... Additional arguments passed temporal_function. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_occurrences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","text":"sf object POINT geometry containing locations simulated occurrences, time_point column indicating associated time point occurrence sampling_p1 column indicating sampling probability associated spatial pattern (see create_spatial_pattern()).","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_occurrences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate species occurrences within a spatiotemporal scope — simulate_occurrences","text":"","code":"# Load packages library(sf) library(ggplot2)  # Create polygon plgn <- st_polygon(list(cbind(c(5, 10, 8, 2, 3, 5), c(2, 1, 7, 9, 5, 2))))  # 1. Random spatial pattern with 4 time points occ_sf <- simulate_occurrences(   species_range = plgn,   n_time_points = 4,   initial_average_occurrences = 100,   seed = 123) #> [using unconditional Gaussian simulation]  ggplot() +  geom_sf(data = occ_sf) +  geom_sf(data = plgn, fill = NA) +  facet_wrap(\"time_point\") +  labs(       title = \"Occurrences with random spatial and temporal pattern\",       subtitle = \"4 time steps\") +  theme_minimal()   # 2. Highly clustered spatial pattern with 6 time points occ_sf_100 <- simulate_occurrences(   species_range = plgn,   spatial_pattern = 100,   n_time_points = 6,   initial_average_occurrences = 100,   seed = 123) #> [using unconditional Gaussian simulation]  ggplot() +   geom_sf(data = occ_sf_100) +   geom_sf(data = plgn, fill = NA) +   facet_wrap(\"time_point\") +   labs(        title = \"Occurrences with structured spatial and temporal pattern\",        subtitle = \"6 time steps\") +   theme_minimal()"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_random_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a random walk over time — simulate_random_walk","title":"Simulate a random walk over time — simulate_random_walk","text":"function simulates timeseries average number occurrences species using random walk time.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_random_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a random walk over time — simulate_random_walk","text":"","code":"simulate_random_walk(   initial_average_occurrences = 50,   n_time_points = 10,   sd_step = 0.05,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_random_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a random walk over time — simulate_random_walk","text":"initial_average_occurrences positive numeric value indicating average number occurrences simulated first time point. n_time_points positive integer specifying number time points simulate. sd_step positive numeric value indicating standard deviation random steps. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_random_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a random walk over time — simulate_random_walk","text":"vector integers length n_time_points average number occurrences.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_random_walk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate a random walk over time — simulate_random_walk","text":"","code":"simulate_random_walk(   initial_average_occurrences = 50,   n_time_points = 10,   sd_step = 1,   seed = 123 ) #>  [1] 50.00000 49.43952 49.20935 50.76806 50.83856 50.96785 52.68292 53.14383 #>  [9] 51.87877 51.19192"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_timeseries.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate timeseries for species occurrences — simulate_timeseries","title":"Simulate timeseries for species occurrences — simulate_timeseries","text":"function simulates timeseries number occurrences species.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_timeseries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate timeseries for species occurrences — simulate_timeseries","text":"","code":"simulate_timeseries(   initial_average_occurrences = 50,   n_time_points = 1,   temporal_function = NA,   ...,   seed = NA )"},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_timeseries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate timeseries for species occurrences — simulate_timeseries","text":"initial_average_occurrences positive numeric value indicating average number occurrences simulated first time point. value serves mean (lambda) Poisson distribution. n_time_points positive integer specifying number time points simulate. temporal_function function generating trend number occurrences time, NA (default). n_time_points > 1 function provided, defines temporal pattern number occurrences. ... Additional arguments passed temporal_function. seed positive numeric value setting seed random number generation ensure reproducibility. NA (default), set.seed() called . NA, random number generator state reset (state calling function) upon exiting function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_timeseries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate timeseries for species occurrences — simulate_timeseries","text":"vector integers length n_time_points number occurrences.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/simulate_timeseries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate timeseries for species occurrences — simulate_timeseries","text":"","code":"# 1. Use the function simulate_random_walk() simulate_timeseries(   initial_average_occurrences = 50,   n_time_points = 10,   temporal_function = simulate_random_walk,   sd_step = 1,   seed = 123 ) #>  [1] 46 52 66 54 52 43 56 38 46 43  # 2. Using your own custom function, e.g. this linear function my_own_linear_function <- function(     initial_average_occurrences = initial_average_occurrences,     n_time_points = n_time_points,     coef) {   # Calculate new average abundances over time   time <- seq_len(n_time_points) - 1   lambdas <- initial_average_occurrences + (coef * time)    # Identify where the lambda values become 0 or lower   zero_or_lower_index <- which(lambdas <= 0)    # If any lambda becomes 0 or lower, set all subsequent lambdas to 0   if (length(zero_or_lower_index) > 0) {     zero_or_lower_indices <- zero_or_lower_index[1]:n_time_points     lambdas[zero_or_lower_indices] <- 0   }    # Return average abundances   return(lambdas) }  # Draw n_sim number of occurrences from Poisson distribution using # the custom function n_sim <- 10 n_time_points <- 50 slope <- 1 list_abundances <- vector(\"list\", length = n_sim)  # Loop n_sim times over simulate_timeseries() for (i in seq_len(n_sim)) {   abundances <- simulate_timeseries(     initial_average_occurrences = 50,     n_time_points = n_time_points,     temporal_function = my_own_linear_function,     coef = slope   )    list_abundances[[i]] <- data.frame(     time = seq_along(abundances),     abundance = abundances,     sim = i   ) }  # Combine list of dataframes data_abundances <- do.call(rbind.data.frame, list_abundances)  # Plot the simulated abundances over time using ggplot2 library(ggplot2) ggplot(data_abundances, aes(x = time, y = abundance, colour = factor(sim))) +   geom_line() +   labs(     x = \"Time\", y = \"Species abundance\",     title = paste(       n_sim, \"simulated trends using custom linear function\",       \"with slope\", slope     )   ) +   scale_y_continuous(limits = c(0, NA)) +   scale_x_continuous(breaks = seq(0, n_time_points, 5)) +   theme_minimal() +   theme(legend.position = \"\")"},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert virtualspecies sample to sf format — virtualsample_to_sf","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"Converts virtual species samples generated virtualspecies package spatial (sf) object compatible gcube workflows. Optionally extracts values raster layers sample locations.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"","code":"virtualsample_to_sf(virtual_sample, raster_lyr = NULL)"},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"virtual_sample list output virtualspecies::sampleOccurrences(), containing sample.points, data frame columns x y, original.distribution.raster, terra::SpatRaster object. raster_lyr Optional. terra::SpatRaster extract values sample locations. example, habitat suitability probability occurrence rasters.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"sf object (point geometry) following columns: id character ID sample point (based row names sample.points). observed Logical value indicating sample observed (TRUE) non-detection (FALSE), based Observed column. ... additional columns sample.points extracted raster layer(s). geometry Point geometry coordinate reference system original distribution raster.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"function typically used first step sampling virtual species distribution applying functions like filter_observations(), add_coordinate_uncertainty(), grid_designation(). See tutorial  \"Create occurrence cubes virtual species\" full workflow example. raster layers provided raster_lyr, values point extracted using terra::extract() appended output.","code":""},{"path":[]},{"path":"https://b-cubed-eu.github.io/gcube/reference/virtualsample_to_sf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert virtualspecies sample to sf format — virtualsample_to_sf","text":"","code":"if (FALSE) { # \\dontrun{ # After generating a virtual species and sampling occurrences # with virtualspecies::sampleOccurrences() virtualsample_to_sf(virtual_sample)  # Optionally extract suitability and occurrence probability virtualsample_to_sf(   virtual_sample,   raster_lyr = c(virtual_species$suitab.raster,                  virtual_species$probability.of.occurrence) ) } # }"},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-137","dir":"Changelog","previous_headings":"","what":"gcube 1.3.7","title":"gcube 1.3.7","text":"Shorten example run time mapping functions #130 Remove white line tutorial “Grid designation custom datasets” #131 Fix mistake tutorial “Grid designation custom datasets” #132","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-136","dir":"Changelog","previous_headings":"","what":"gcube 1.3.6","title":"gcube 1.3.6","text":"Use DOI funding","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-135","dir":"Changelog","previous_headings":"","what":"gcube 1.3.5","title":"gcube 1.3.5","text":"Use ROR copyright holder","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-134","dir":"Changelog","previous_headings":"","what":"gcube 1.3.4","title":"gcube 1.3.4","text":"Fix NEWS file","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-133","dir":"Changelog","previous_headings":"","what":"gcube 1.3.3","title":"gcube 1.3.3","text":"Update tutorial grid designation data","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-132","dir":"Changelog","previous_headings":"","what":"gcube 1.3.2","title":"gcube 1.3.2","text":"Add frictionless package suggests","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-131","dir":"Changelog","previous_headings":"","what":"gcube 1.3.1","title":"gcube 1.3.1","text":"Allow grid designation CRS degrees #113 Create tutorial grid designation data #115","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-130","dir":"Changelog","previous_headings":"","what":"gcube 1.3.0","title":"gcube 1.3.0","text":"Fix mistake multispecies vignette #108 Add progress argument map_* functions #109 Add default value missing coordinateUncertaintyInMeters grid designation #114 Change sampling_status column output sample_observations() logical output column called observed Create virtualsample_to_sf() function work virtual species #75 Check package lintr::indentation_linter()","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-120","dir":"Changelog","previous_headings":"","what":"gcube 1.2.0","title":"gcube 1.2.0","text":"Add tutorial work virtual species.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-112","dir":"Changelog","previous_headings":"","what":"gcube 1.1.2","title":"gcube 1.1.2","text":"Join R-universe!","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-111","dir":"Changelog","previous_headings":"","what":"gcube 1.1.1","title":"gcube 1.1.1","text":"Add elaborate package description #102. Uniform naming articles start headings h2 #103. Add DOI citation file #104.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-110","dir":"Changelog","previous_headings":"","what":"gcube 1.1.0","title":"gcube 1.1.0","text":"Publish release Zenodo.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-100","dir":"Changelog","previous_headings":"","what":"gcube 1.0.0","title":"gcube 1.0.0","text":"Add package origin story.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-040","dir":"Changelog","previous_headings":"","what":"gcube 0.4.0","title":"gcube 0.4.0","text":"Consolidate documentation across functions, README, vignettes. Use lapply() instead -loop Randomise points raster cells. Fix issues (#37, #70, #76).","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-030","dir":"Changelog","previous_headings":"","what":"gcube 0.3.0","title":"gcube 0.3.0","text":"generate_taxonomy() also creates species key. Fix bug mapping simulate occurrences without specified temporal function.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-020","dir":"Changelog","previous_headings":"","what":"gcube 0.2.0","title":"gcube 0.2.0","text":"Improve function checks stopifnot() assertthat package. Add missing unit tests. Set repo status active. Use tidy contributing code conduct.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-010","dir":"Changelog","previous_headings":"","what":"gcube 0.1.0","title":"gcube 0.1.0","text":"Create data cube multiple species using purrr::pmap(). Generate species taxonomy. Change vignettes articles. Create article multi-species approach. Add name rationale README. Clarify pkgdown website page names.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-001","dir":"Changelog","previous_headings":"","what":"gcube 0.0.1","title":"gcube 0.0.1","text":"Add checklist infrastructure.","code":""},{"path":"https://b-cubed-eu.github.io/gcube/news/index.html","id":"gcube-000","dir":"Changelog","previous_headings":"","what":"gcube 0.0.0","title":"gcube 0.0.0","text":"Added NEWS.md file track changes package.","code":""}]
